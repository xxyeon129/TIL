# ☑️ Defining Routes

## Creating Routes

- Next.js는 폴더를 사용해 경로를 정의하는 파일 시스템 기반 라우터를 사용

- 각 폴더는 URL 세그먼트에 매핑되는 경로 세그먼트를 나타냄

- 중첩된 경로를 만들려면 폴더를 서로 중첩하면 됨

  - 연결하고 싶은 url로 폴더명을 생성한 후 해당 폴더 내에 page.tsx 생성
  - ex) app/dashboard/setting/page.tsx

- 어떤 설정이나 router 설치 없이도, `app` 폴더 안에 react component를 만들면 → 자동적으로 서버의 home으로 가보면 page.tsx의 ui가 렌더링되는 것을 확인할 수 있음

- 경로 여러개 → 폴더 내 폴더 구조로 한 후 page.tsx 생성
  - 폴더에 page.tsx가 없다면 해당 폴더명의 url로 접근했을 때 404 페이지
  - page.tsx가 없다면 경로의 일부분이 되는 폴더로만 존재하는 것 (추천하는 방식은 아님)

## Creating UI

- 각 경로 세그먼트에 대한 UI를 생성하는 데 특수 파일 규칙이 사용

- 가장 일반적인 것은 경로에 고유한 UI를 표시하는 페이지와 여러 경로에서 공유되는 UI를 표시하는 레이아웃

- page.tsx가 있는 폴더에 components 폴더를 만들고 파일명이 page.tsx가 아닌 파일명 컴포넌트로 만든 후 page.tsx 파일에서 해당 컴포넌트를 import해서 써오는 방식도 존재 → url 경로로 작동하지 않음

<br />
<br />

# ☑️ Not Found Routes

## Not Found

app 폴더의 root 경로에 not-found.tsx 파일 생성

→ 설정하지 않은 url 경로에 접근 시 not-found.tsx 파일의 UI 렌더링

## Link

React와 동일하게 페이지 이동 시 a 태그가 아닌 `Link`를 사용

```tsx
import Link from 'next/link';

<Link href="/">Home</Link>;
```

## usePathname

현재 URL의 pathname을 읽을 수 있게 해주는 클라이언트 컴포넌트 훅

```tsx
import { usePathname } from 'next/navigation';
const path = usePathname();
```

## React client hook in Server Component 오류

서버 컴포넌트에서 React 클라이언트 훅을 사용하고 있을 때 발생하는 오류로 `"use client"` 를 추가해 클라이언트 컴포넌트로 바꿔줘야 함

<br />
<br />

# ☑️ SSR vs CSR

## CSR; Client Side Rendering

CRA만 사용할 경우 client side rendering → 모든 UI building이 client측에서 발생

1. client는 JS를 로드
2. 그 후에 JS가 UI를 빌드

프레임워크 없이 React만 사용할 경우 JavaScript에 의해 태그가 페이지에 추가됨 → 사용자가 페이지에 접근하면 → 브라우저가 모든 JS 파일을 다운로드하고 실행하기 전까지는(브라우저의 JS 엔진에 의해 추가되기 전까지는) 빈 화면임

→ UI를 보려면 JS가 필요

→ 데이터 연결 상태가 좋지 않은 상태에서 웹사이트 방문 시 JS 파일이 다운로드 완료될 때까지 기다려야 함. UI 없는 빈 화면은 더 오래 보게 됨

### 검색 엔진 최적화(SEO; Search Engine Optimization)

많은 검색 엔진이 페이지의 HTML을 보기 때문에 빈 페이지를 보여주지 않는 것이 좋음

<br />

## SSR; Server Side Rendering

> [!NOTE]
>
> **rendering:**
>
> Next.js가 React components(JS function)를 가져와서 → (React code를) 브라우저가 이해할 수 있는 HTML로 변환하는 작업

Next.js로 웹사이트를 빌드할 때는 자동적으로(automatically) default로 server side rendering이 사용됨

- 페이지의 UI가 모두 실제로 브라우저 코드에 존재

- 화면에 표시할 HTML을 가지고 있기 때문에 → JS가 로드될 때까지 브라우저가 기다릴 필요가 없음

- Next.js application의 모든 page 안의 모든 component들은 우선 server에서 render됨

- 사용자에게 HTML을 주기 전, Next.js는 server(backend)에서 application(모든 컴포넌트)을 render → HTML로 변환 → 그 HTML을 브라우저 request에 대한 response로 넘겨줌
  - 사용자는 Next.js가 backend에서 생성한 HTML을 보게 됨
  - 사용자가 페이지에 도착했을 때 → 최초 application의 UI 빌드에서 JS에 의존하지 않음 (UI는 이미 빌드되어 있고 HTML도 이미 존재함)

> [!CAUTION]
> Next.js의 모든 컴포넌트와 페이지들은 먼저 backend(server side)에서 render된다 (`"use client"` 사용 여부와 상관 없음)

<br />
<br />

# ☑️ Hydration

nav를 클릭했을 때 처음에는 anchor 묶음이었다가 → Link component가 처리 (client side only navigation 수행) → React component로 변환 → 페이지 전체를 새로고침하지 않고 빠르게 navigate할 수 있게 됨

1. click

2. 프레임워크(Next.js)는 클릭 요청을 보고 component를 UI를 가지고 있는 dummy HTML로 변환 (non-interactive, backend에서 생성)

   - React app initialized에 시간이 걸리는 환경일 경우 UI는 보이지만 navigate할 경우 새로고침이 일어나게 됨

3. HTML에 React, components.. load 시작 → React application initialized

4. application이 React App이 됨 (interactive)

> [!NOTE]
>
> **hydration:**
>
> SSR을 통해 만들어진 non-interactive HTML을 client 측 JavaScript를 사용해 interacive한 React application으로 초기화(initialize)하는 작업
> (서버 환경에서 이미 렌더링된 HTML에 React를 붙이는 것)

<br />
<br />

# ☑️ “use client”

client component를 사용하려면 파일 상단, import 위에 `"use client"` 지시어를 추가하면 됨

- `"use client"`는 서버와 클라언트 컴포넌트 모듈 간 경계를 선언하는 데 사용됨

- client에서만 render된다는 의미는 아님. 하위 컴포넌트를 포함해 해당 파일로 가져온 다른 모든 모듈이 클라이언트 번들의 일부로 간주됨

  - backend에서 render되고 frontend에서 hydrate/interactive됨을 의미함
  - use client를 선언하지 않으면 기본적으로 모두 server component가 됨

- use client components는 server에서 먼저 render되고나서 → hydrate됨

- server component는 server에서 먼저 render 되고, hydrate는 되지 않음
  - 사용자가 다운로드받아야 할 JavaScript의 양이 작아진다는 의미
  - 페이지 로딩 속도 향상
  - 사용자는 use client를 가진 components의 JavaScript 코드만 다운받게 되기 때문

<br />
<br />

# ☑️ Layouts

Next.js는 layout component(layout.tsx)에 있는 export된 default component를 렌더링함

- 레이아웃 컴포넌트 내에 URL로 인식한 page component가 있는 것
- 모든 페이지에 존재하는 Nav바를 layout component의 children과 함께 두면 → 모든 페이지에 Nav바 코드를 중복하여 쓸 필요 없이 모든 페이지에 Nav바가 표시됨

```tsx
// app/layout.tsx

import Navigation from '../components/navigation';

export const metadata = {
  title: 'Next.js',
  description: 'Generated by Next.js',
};

export default function RootLayout({ children }: { children: React.ReactNode }) {
  return (
    <html lang="en">
      <body>
        <Navigation />
        {children}
      </body>
    </html>
  );
}
```

<br />

## Layout 중첩

사용자가 있는 페이지에 따라 추가적인 레이아웃을 가질 수 있음 → 추가적으로 레이아웃을 적용하고 싶은 경로 폴더 내에 새로운 `layout.tsx` 파일을 만들어 적용

- metadata 삭제
- html, body 태그 삭제
- div 태그로 children 감싸기

```tsx
// app/about-us/layout.tsx

export default function Layout({ children }: { children: React.ReactNode }) {
  return (
    <div>
      {children}
      &copy; Next JS is great!
    </div>
  );
}
```

<br />

Next.js는 상위 폴더로 이동하여 레이아웃이 있는지 확인하고 레이아웃이 있는 경우에는 이 레이아웃을 사용해 하위 항목을 렌더링함

1. root `<Layout>`을 가져와 렌더링

2. URL 확인

3. 해당 URL 경로 폴더로 이동, 해당 폴더에 layout 파일이 있는지 확인

4. 있다면 root layout 내부에 해당 layout 위치

5. 해당 URL 경로 폴더의 하위 모든 폴더 내에 layout 파일이 있는지 확인 → 없다면 페이지만 렌더링, 있으면 layout 내부에 layout 위치

<br />

> [!NOTE]
>
> **💡 layout을 특정 경로에서 비활성화하기**
>
> - server component인 layout.tsx 파일 자체가 아니라,
>
> - navigation.tsx 파일에서는 이미 “useclient”와 usePathname()을 사용했기 때문에
>
> - layout.tsx 파일 안에서 렌더링하는 navigation.tsx 파일에서 분기 처리하는 것이 최선이지 않을까..?
>
> - 그렇게 되면 공통 컴포넌트를 제외하고 싶은 URL 경로에서도 일단 navigation.tsx 파일 자체를 실행하는 것이기 때문에, 화면상에 UI를 보여주지 않을 뿐, JavaScript 코드 자체는 실행하므로 성능상의 이점이 얼마나 있는지는 모르겠음

<br />
<br />

# ☑️ Metadata

Next.js에는 향상된 SEO를 위해 애플리케이션 metadata(ex: HTML head 엘리먼트 내의 meta 및 link 태그)를 정의하는 데 사용할 수 있는 metadata API가 존재

## route groups

- 폴더 이름을 괄호로 묶어서 사용 ex. (home)/page.tsx

  - 괄호로 묶일 경우 **URL 경로를 생성하지 않음**
  - 괄호 안 이름은 마음대로 해도 됨

- root layout을 사용하지 않고 대신 여러 레이아웃을 사용할 수 있게 해줌

- 레이아웃 중에서 선택하거나 선택 해제하여 사용할 수 있음 → 중첩 레이아웃을 원하지 않는 경우 route groups를 사용할 수 있음

- metadata는 layout과 다르게 실제로는 중첩되지 않고 병합됨

  - title, description이 각각 다른 파일의 metadata에 존재할 경우 실행 페이지에서 보면 병합되어 있음

- page나 layout만 metadata를 내보낼 수 있음
  - component에서는 metadata를 내보낼 수 없음
  - metadata는 server component에서만 있을 수 있음 (client component에서 있을 수 없음)

## 중복되는 metadata에 대한 template

```tsx
// app/layout.tsx
export const metadata: Metadata = {
  title: {
    template: '%s | Next Movies',
    default: 'Next Movies',
  },
  description: '',
};

// app/about-us/page.tsx
export const metadata = {
  title: 'About us',
};

// app/not-found.tsx
export const metadata = {
  title: 'Not found',
};
```

<br />
<br />

# ☑️ Dy**namic Routes**

- 동적 세그먼트는 폴더 이름을 대괄호로 묶어 생성 ex: movies/[id]
  - Next.js에게 movies/ 뒤에 어떤 경로가 들어가도 괜찮다는 것을 알려주는 것
- URL을 표시하려면 해당 폴더 내에 page.tsx 생성
  - movies/121212 경로에 접근 시 해당 page.tsx UI가 표시됨

```tsx
// movies/[id]/page.tsx

export default function MovieDetail(props) {
  console.log(props); // backend 콘솔에서 표시됨
  // { params: { id: '121212' }, searchParams: {} }
  return <h1>Movie</h1>;
}
```

/movies/3454545?region=kr&page=2 경로로 접근 시 콘솔에 표시되는 내용 → `{ params: { id: '3454545' }, searchParams: { region: ‘kr’, page: ‘2’ } }`

```tsx
export default function MovieDetail({ params: { id } }: { params: { id: string } }) {
  return <h1>Movie {id}</h1>;
}
```
