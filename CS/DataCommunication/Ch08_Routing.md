> [!NOTE]
>
> 라우팅: 패킷의 전달 경로 설정

<br />

# Ch08 Routing

<aside>
💡

라우팅: 패킷의 전달 경로 설정

</aside>

# 01 라우팅 개요

**라우팅:** 정보를 목적지까지 전송하기 위해 / 가장 효과적인 전송방법을 결정하는 것

- 인접한 라우터들의 **네트워크 정보와 metric값**을 받아서 → **최적의 경로를 선택**하여 **목적지까지 패킷을 전송**할 수 있게 하는 기능 (metric: 최적의 경로를 설정하는 값)
- 패킷을 전송하기 위해 송신측에서 **목적지까지의 경로를 정하고**, **정해진 경로를 따라 패킷을 전달하는 일련의 과정**
- 패킷을 전송하기 위한 **수많은 경로 중 한 가지 경로를 결정**하는 것
- **`라우팅 테이블`:** 라우팅을 위해 네트워크 상의 모든 라우터들은 **목적지에 따라** **패킷을 보낼 interface를 먼저 계산**해 놓아야 하는데, **이를 계산해놓은 것**

## ✅ Routed Protocol

- 라우팅을 당하는 = 라우터가 라우팅해주는 고객
- TCP/IP, Novel IPX, Apple Talk…

## ✅ Routing Protocol

**라우터 내부**에서 라우팅 알고리즘을 수행하는 프로토콜

- **RIP(Routing Information Protocol: 거리 벡터),**
- **IGRP(Interior Gateway Routing Protocol: 내부 게이트웨이 프로토콜),**
- EIGRP(Enhanced Interior Gateway Routing Protocol),
- OSPF(Open Shortest Path First),
- BGP(BorderGatewayProtocol),EGP(ExteriorGatewayProtocol),
- ES-IS(EndSystemtoIntermediateSystem),
- IS-IS(IntermediateSystemtoIntermediateSystem)

## ✅ 라우팅을 하기 위한 라우터의 역할

1️⃣ 경로 정보 수집 → 2️⃣ 라우팅 프로토콜 적용 → 3️⃣ 라우팅 광고 → 4️⃣ 라우팅 테이블 생성

- **인접한 라우터로부터 정보를 수집**
- 수집한 정보를 가지고 → 목적지로 가기 위해 **어떤 경로를 통해 패킷을 전달**할 수 있는지 판단하여 **라우팅 테이블을 만듦**

## ✅ 정보 전달 수행 절차

호스트가 TELNET으로 서버 접속 시 수행 절차

1️⃣ 주소 인식 → 2️⃣ 라우팅 테이블 검색 → 3️⃣ 최적의 경로 설정 → 4️⃣ 패킷 전달

## ✅ 경로 결정 요소 Metric

라우터는 인접한 라우터로부터 전달 받은 경로 정보로 **비용**을 계산해 → 최적의 경로를 설정

→ 이 **비용을 계산하는데 영향**을 미치는 요소가 **Metric**

- 라우터는 Metric을 사용하여 / 경로결정 요소들의 상태를 → 수치로 표현하여 계산 → 이 값을 **비용(Cost)**이라 함
- **관리자가 선택한 라우팅 프로토콜**에 따라 / 경로결정 요소들의 **우선순위**가 반영
  - 일반적으로 **가장 적은 비용의 경로**를 최적의 경로로 결정
- 홉 수(Hop Count), 대역폭(Bandwidth), 지연(Delay), 신뢰도(Reliability), 부하(Load) 등

### 1️⃣ 홉 수(Hop Count)

- 하나의 홉 == 하나의 라우터를 지나가는 것
- 라우터를 지날 때마다 **지연**이 발생 → 거쳐가는 **라우터 수가 적은 경로 (홉 수가 적은 경로)**로 패킷을 전달하는 것이 빠르고 안정적
- 라우터와 라우터가 직접 연결 되어 있을 때 거리를 1홉이라고 함 (본인 제외 라우터개수)

### 2️⃣ 대역폭 (Bandwidth)

- 링크의 대역폭 == 전송 매체 간의 **전송능력**
- 대역폭이 **넓은** 링크가 → 전송속도가 빠른 최적의 경로

### 3️⃣ 지연 (Delay)

패킷을 목적지까지 전송하는 과정에서 발생한 **전송지연 시간**

- 네트워크의 링크의 회선 속도, 각 경로 당 라우터의 큐 길이, 링크의 네트워크 정체, 물리적 회선 거리 등 **많은 요인에 의해 결정**됨

### 4️⃣ 신뢰도 (Reliability)

**회선 상태**가 불안정할 경우 신뢰도 하락

각 링크의 **비트-에러율로 전송 손실이나 전송 에러에 대한 정보를 참조**해 신뢰성을 판단

- 신뢰도 값은 대부분 라우터에 의해 동적으로 **자동계산** but 관리자에 의해 수동 할당도 가능

### 5️⃣ 부하 (Load)

회선 사용량을 의미

- 정해진 회선 속도에서 **많은 사용자가 패킷을 전송**하게 되면 → 그만큼 다른 사용자가 사용할 수 있는 회선의 사용량이 적음
- 전송 매체에서 **네트워크 자원 사용량**을 나타내는 것 → 부하가 많이 발생하면 라우터의 CPU나 메모리의 많은 부담을 주게 됨
- 지연 시간이 짧더라도, 링크로 전송되는 패킷이 너무 많으면 체증 발생하여 지연 시간이 더 증가 → 부하 상황에 따라 라우팅 프로토콜이 부하정도를 주기적으로 비교하여 자원의 사용 경향 확인

### + 관리 거리(Administrative Distance)

관리거리값🔻 신뢰성🔼 우선순위🔼

모든 라우팅 프로토콜은 0 ~ 255 사이 **관리 거리 값**을 가지고 있음 → **값이 적을수록 신뢰성**이 높음

여러 개의 라우팅 프로토콜이 존재할 경우 → **관리거리 값이 낮은** 프로토콜로부터 받은 경로를 라우팅 테이블에 등록

- RIP(Routing Information Protocol: 거리 벡터)만 운영 → 홉 수가 적은 라우터 우선
- IGRP(Interior Gateway Routing Protocol: 내부 게이트웨이 프로토콜)만 운영 → 비용(Cost)이 적은 라우터 우선
- RIP, IGRP 동시 운영 시 → 관리 거리 값을 사용하여 결정

## ✅ 라우팅 프로토콜의 구성

### 1️⃣ Routing Table

- 패킷을 **목적지로 라우팅**할 때 **참조하는 테이블**
- 목적지 주소, Output interface, Metric값(목적지 이르는 최적경로를 결정하는데 사용되는 값)

### 2️⃣ Message

- 라우터 간 라우팅을 위해 교환하는 메시지
- 이웃 도달 메시지, 라우팅 정보

### 3️⃣ Metric

- Routing Table 생성 / 업데이트 시 최적의 경로를 결정하는 값
- 홉 수, 대역폭, 지연, 신뢰도, 부하, 경로 길이 등

## ✅ 라우팅 프로토콜의 종류

라우팅 프로토콜: 네트워크 정보의 생성, 교환을 제어하는 프로토콜

### ✔️ 정적(Static) 라우팅 프로토콜

네트워크 **관리자가 직접 목적지별로 네트워크 경로를 지정**하는 방식

- ✨ 데이터가 전달되는 경로를 관리자가 직접 제어해 → **안정성이 높음**
- ✨ **라우팅 테이블**을 **이해하기 쉬움**
- ✨ **라우터 부하 경감, 고속 라우팅** 가능
- 💩 라우터가 **많고 목적지가 많은 경우 설정이 어려움**
- 💩 장애가 발생했을 경우 **대처가 어려움** (정해진 경로 문제 발생 시 라우팅 불가능)
- 💩 네트워크 **변화가 심할 때 부적합**
- 💩 큰 네트워크에는 부적합
- 💩 관리자의 **관리부담 증가**

### ⭐ ✔️ 동적(Dynamic) 라우팅 프로토콜

**라우터가 스스로 라우팅 경로를 동적으로 결정**하여 → 네트워크 변화에 능동적으로 대처

라우팅 프로토콜을 통해 / 라우터 간 **경로 정보를 교환**해 → 최적의 경로를 설정

- ✨ 데이터가 전달되는 **경로를 자동으로 결정**
- ✨ **장애 발생 시 대처가 쉬움**
- ✨ **큰 네트워크에 적합**
- ✨ 다양한 경로 이용 가능
- 💩 설정 및 운영지식 습득 필요 → **관리자의 능력에 따라 안정적, 비안정적**이 결정됨
- 💩 데이터가 전달되는 경로를 관리자가 제어할 수 **없음**
- 💩 **안정성이 낮음 → 장애가 발생할 가능성**이 있음

> [!NOTE]
>
> 자동으로 경로 상태를 일정 주기마다 전달, 데이터를 저장하는 경로가 자동으로 결정된다. 자동으로 되기 때문에 관리자가 제어할 수 없음. ⭐ **자동으로 경로를 설정해주는 이점**

<br />

# 02 Routing Process

## ✅ 계층별 비교 OSI 7 Layer와 TCP/IP

## ✅ 3계층(네트워크 계층)에서 동작하는 라우터

두 개의 LAN이 연결 (Host-스위치-라우터가 하나의 LAN)

두 개 연결된 게 인터넷 망이다. (인터넷: 라우터와 라우터의 연결)

Host A → B 로 송신을 할 때 물리 계층까지 내려갔다가 스위치를 통하고 라우터 네트워크계층까지 올라갔다가 다시 라우터, 스위치를 통해 Host B로 전달됨

각 계층마다 규칙을 지켜야 함.

## ✅ 라우팅 테이블

목적지, 다음에 가야 할 라우터, 가는 데 비용을 표로 나타낸 것

- 1번 라우터: 갈 수 있는게 2, 4 두 경로로 갈 수 있음 cost가 싼 2번으로 감 next:2, cost:1
- 2번에 온 상태에서 3번을 간다고 해보자. cost가 싼 5로 이동하고, 3으로 이동

최소비용을 따짐

## ✅ ARP (Address Resolution Protocol; 주소 결정 프로토콜)

네트워크에서 IP주소를 **물리적 주소로 대응(bind)**시키는 기능

라우팅 테이블 동작과정

- ARP **요청은 브로드캐스트**로, **응답은 유니캐스트**로 저장

## ✅ Routing Process

1. 각 라우터별로 관리하는 **호스트IP**와 **MAC주소** 획득, **라우팅 테이블**
2. **라우팅 정보 교환**
3. **호스트와 라우터 사이 데이터링크** 링크,
   1번 라우터의 라우팅 테이블에서 **수신IP의 라우터 검색**
4. 호스트가 ARP(주소 결정 프로토콜)를 사용해 **수신자의 MAC 주소 파악**
   라우팅 테이블에 따라 라우팅

<br />

# 03 RIP (Routing Information Protocol)

## ✅ RIP (Routing Information Protocol) 개요

- **거리 벡터 알고리즘**에 기초해 개발된 라우팅 프로토콜
- 라우팅 Metric으로 홉 카운트(Hop Count)만 사용
  - 가장 단순한 라우팅 프로토콜
  - 경로 비용을 단지 홉 수로만 판단 → 💩 속도, 거리 지연은 고려하지 않아 비효율적
  - **최대 홉 수의 제한**
    - 최대 15 홉 수 (16은 무한대)로 제한 → 홉 수는 라우터를 통과할 때마다 1씩 증가
- 라우터는 **주기적으로 이웃 라우터와 라우팅 정보 교환**
  - 자신의 라우팅 테이블을 주기적으로 이웃 라우터에게 전송
  - 이웃 라우터로부터 라우팅 정보를 수신하여 자신의 라우팅 테이블을 갱신하고 이를 통해 경로 선택
- IGP(Interior Gateway Protocol: 내부 게이트웨이 프로토콜)용
- UDP segment에 캡슐화되어 사용됨
- 소규모 또는 교육용 등 간단한 네트워크에 주로 사용됨

> [!NOTE]
>
> 홉 카운트만을 사용함. 최적의 경로로 선정하는데
>
> 홉 카운트라고 해서 속도, 거리 지연이 발생할 수 있는데 RIP는 그런 걸 고려하지 않고 홉 수 만 따지기 때문에 비효율적이다.
>
> 최대 홉 수를 제한하고 있다. 총 15개까지. 더 건너가게 되면 더 이상 전달을 할 수 없다.
>
> 라우터 통과할 때마다 1씩 증가해서 16이 되면 추가 못하는 것
>
> UDP 조각 안에 캡슐화가 된다. UDP 포트를 사용해 RIP 메세지를 서로 주고받을 수 있다.

## ✅ RIP 패킷 형식

- 클라스 라우팅 수행
  - Subnetwork 정보가 아닌, **Class 형태의 라우팅 정보만 전달**함 → 라우팅 정보량이 많음
- 주기적인 라우팅 업데이트
  - 매 30초마다 RIP 응답 메세지(RIP 패킷)를 브로드캐스팅 (목적지 IP 주소 255.255.255.255)
  - 상대에게서 수신된 네트워크 정보를 제외한 모든 네트워크 정보를 상태에게 알려줌
    (수신 라우터는 자신의 라우팅 테이블을 재작성하도록 함)
  - 네트워크 경로 항목에서 더 짧은 홉 수를 수신받았을 때만 해당 **라우팅 경로 항목을 교체**함

## ✅ RIP 패킷 메세지 (요청, 응답)

### 요청 패킷

- 라우터가 처음 부팅됐을 때 전송
- 특정 목적지 정보가 타임아웃됐을 때 전송
  - 타임아웃 시간 동안 라우팅 정보 수신이 이루어지지 않으면
    → 의미 없는 목적지로 간주
    → 일정 시간 후 라우팅 테이블에서 삭제

### 응답 패킷

- 매 **30초마다 주기적으로 이웃 라우터에게 전송**
- 트리거 갱신 시 → 자신의 **라우팅 테이블에 변화가 생겼을 때** 전송

> [!NOTE]
>
> 데이터 링크에는 프레임 헤더가 붙음. 목적지 주소는 MAC address에 해당.
>
> UDP는 발신지의 포트주소, 수신지의 포트주소가 해당됨
>
> ---
>
> 요청 패킷은 라우터가 부팅될 때 이웃에 있는 놈들에게 다 전달된다.
>
> 이웃에 있는 라우터가 30초마다 주기적으로 전송해준다.
>
> 트리거: 처음 경로 변경이 생겼을 때 **경로를 업데이트**해주는 것.
>
> - 경로가 변경되면 옆에 있는 애들한테 알려줘야 함. 업데이트됐다는 걸 연쇄적으로 전달되어야 한다.
>
> 시간이 오버되면(홉카운트가 16) 의미 없는 목적지로 간주된다.

## ✅ RIP 타이머 (라우팅 경로 업데이트 방식)

### Update 타이머: 30초

**라우팅 테이블 전체를 브로드캐스트 또는 멀티캐스트 방식으로 송출**

### Timeout 타이머: 180초

라우팅 테이블에있는 매 경로마다 Timout 타이머를 둠

업데이트 정보(RIP 응답 메시지)에 **해당 경로가 있으면 → Timout 타이머 초기화**

Timout 타이머 종료 시까지 **해당 경로가 없으면 → 도착 불가능(16,무한)으로 표시**

### Garbage Collection 타이머: 120초

**도착 불가능 16홉 수(무한)로 표시**하고 **주변에 알리며**, **즉각 삭제 유예하는 시간**

### Flush 타이머: 240초

**업데이트 없는 경로** → 라우팅 테이블에서 **해당 경로를 제거**

### Triggered Update (트리거 갱신, 연쇄 업데이트)

토폴로지 변화 시 업데이트 타이머 종료 전이라도 **즉각 라우팅 업데이트 정보 송출**

> [!NOTE]
>
> RIP 버전, IP주소, 홉 카운트 등..
>
> 경로 업데이트가 생기게 되면 30초로 제한되어 있음.
>
> 타임아웃 180초를 가지고 넘어가게 되면 도착불능(16,무한)으로 표시, 즉각 삭제를 유예해줌
>
> Flush 타이머: (flush: 물을 내림) 업데이트 경로가 없는 건 경로를 지워버리는 것
>
> Triggered Update: 연쇄적으로 업데이터 정보를 송출하는 것

## ✅ 💩 RIP 문제점

### 늦은 수렴성 (Slow Convergence)

라우터들끼리 주기적으로(30초 간격) **경로 업데이트**

**경로 재계산함**에 따라 몇 개 라우터만 지나도 수 분 이상이 걸림

### 라우팅 트래픽 부하

전체 경로를 담은 라우팅 테이블을 주기적으로 브로드캐스트 → **네트워크에 트래픽 부하**를 줌

### 라우팅 루프

모든 라우터들 사이에 동기화를 시켜주지 않으면 패킷의 경로가 부적절한 루프를 돌 수 있음

매 30초마다 업데이트되기 때문에 → 다운(Down) 등의 나쁜 소식이 **늦게 전달되어 → 잘못된 경로로 무한루프를 도는 문제** 발생

### 무한 카운트 문제 (Count-to-Infinity Problem)

느린 수렴 시간 때문에 → 나쁜 경로를 다른 라우터에게 전할 때 라우터가 더 느리게, 더 나쁜 정보로 다른 라우터에게 전하면서 결국 무한(16) 홉 수로 가는 현상

> [!NOTE]
>
> 바로 반영해주는 게 아니라, 반영하는 시간이 많이 걸린다.
>
> 경로 설정하는 데 수 분 이상이 걸린다.
>
> 브로드캐스팅 → 모든 라우터에게 다 보내주는 거니까 네트워크 트래픽에 부하를 준다
>
> 루프: 세 개 라우터가 쭈르륵 놓여 있으면 연쇄적으로 트리거되어야 함. 동기화시켜주지 않으면 경로가 끊어져 무한 루프에 빠지게 된다.
>
> 무한 카운트 문제: 수렴 시간이 늦기 때문에 나쁜 경로에 전달되게 되면 계속해서 무한히 나쁜 경로를 전달하게 되어 무한 홉 수 (16)로 가는 현상

## ✅ RIP 문제점 해결방안

- 최대 홉 수 제한
- 트리거 갱신: 변경 시 즉시 통보하여 복구 시간을 줄임
- Hold on Timer: 무한대인 경로에 대해 / 전체 네트워크 경로가 새로 갱신될 때까지 일정 시간 기다림
- Split horizon: 라우팅 정보를 전달해준 인터페이스로 재전송하지 않아 → 루프 방지
- **Route poison / Poison Reverse:** 회선이 고장난 경우 **즉시 홉을 16으로 지정**해 **전체 네트워크에 전송**
  - **`Route poisoning`:** 특정 네트워크가 down되면 즉시 down된 네트워크의 metric 값을 16으로 설정 → 인정 라우터에게 **flash update**를 전송하여 해당 네트워크가 다운됐다는 걸 알림
  - **`Poison reverse`**: route poisoning을 받은 라우터는 자신의 RIP 데이터베이스를 보고, 해당 네트워크에 대한 **대체 경로**가 없을 시 route poisoning을 보낸 인접 라우터에게 해당 네트워크의 metric값을 16으로 설정해 역으로 보내서 → 대체 경로가 없다는 것을 알려줌

<br />

# 04 OSPF (Open Shortest Path First)

## ✅ 공개 최단경로 프로토콜 개요

- 링크 상태 라우팅 프로토콜 기초
  - 자율시스템(AS) 내부의 라우터들끼리 IGP(Interior Gateway Protocol) 라우팅 정보를 교환하는 라우팅 프로토콜
- Link State 기술에 의한 **최단경로 선택 라우팅 알고리즘**
  - 다익스트라의 SPF(Shortest Path First) 알고리즘 사용: 하나의 정점에서 → 모든 경로로 가는 최단경로 계산 (거리가 가장 짧은 걸 지정)
- 네트워크 환경에 변화 시 **빠른 재수렴(Fast Reconvergence)** / **부분갱신(Partial Update)**
  - 네트워크가 안정되면 → **라우팅 갱신 정보만 전달**됨
  - 네트워크 토폴로지가 변경됐을 때 신속하게 적용 → 장애 즉시 감지
  - 링크 상태가 **변경될 시에만** 라우팅 정보 전송
  - 변경된 정보를 LSP(Link State Packet)에 담아 모든 OSPF 라우터에 플러딩
  - LSP 수신 시 즉시 DB 갱신
- 영향을 주는 요인
  - 장애 감지: 인터페이스 상태 변화(ex. Dead Timer 시간 내(180초) 이웃 라우터로부터 hello 패킷이 수신되지 않았을 때)
  - 경로 계산: 네트워크 크기, DB 내 경로 개수에 따라 달라짐
- 라우팅 metric으로 **링크 비용**을 사용
  - 목적지까지 최적의 경로 선택을 위한 라우팅 metric으로 **Link Cost** 사용
- **네트워크를 영역으로 나누어 구분**
  - 자율시스템(AS, Autonomous System) 내부에 `Area` 필드를 두어 → Level2에 의한 계층적 라우팅 구현
  - 라우팅 테이블의 항목 수를 줄임, 전달되어야 하는 라우팅 정보를 줄임
    → 라우터의 부하 경감, 유지관리 편의성 제공
  - 각 라우터는 특정(소속) 영역에 대한 링크 상태 DB(LSDB)를 구축
- ✨ 중앙의 데이터베이스를 통해 모든 라우터들이 공통된 경로를 사용 → 수렴 시간 감소, 라우팅 트래픽 양 감소

> [!NOTE]
>
> 공개: 누구든지 똑같이 다 적용. 개방형.
>
> 링크 상태를 따져서 (앞에서는 홉 카운트만 따짐) 라우팅을 함
>
> - 자율 시스템 내부의 라우팅 정보를 교환
>   - 내부에서 움직이는 것: IGP (그림에서 오른쪽 파란색 덩어리)
> - 네트워크 환경이 바뀔 경우: 빠르게 재수렴하고 부분 갱신(변경된 것만 업데이트. 변경분만 전달해줌. 바뀌지 않은 라우팅 정보는 건드리지 않음)
> - AS와 AS 사이 라우팅 → 레벨2 라우팅. AS 내부에서 목적지를 찾아감
> - CIRD(Classless InterDomain Routing): Class가 없는 도메인 간 라우팅
>
>   - 네트워크를 더 쓰고 싶다면 8비트 중에서 1비트를 네트워크 쓰게 만들어줌 → 네트워크 수는 많아지지만, 호스트는 줄어듦 → 이걸 Variable Length… 가변길이임.
>
> - AS와 다른 도메인을 연결: AS 경계 라우터

## ✅ 링크 상태 알고리즘 (Link State Algorithm)

라우터는 이웃에 대한 연결정보를 다른 모든 라우터에 전달

네트워크 전체 토폴로지에 대한 정보를 얻고 → 이를 바탕으로 최적의 경로 선택

- OSPF(공개 최단경로 프로토콜)는 링크 상태 알고리즘을 사용
  - 네트워크 변화 시 → 플러딩 과정을 통해 갱신

**[플러딩(Flooding)]**

링크 상태 프로토콜을 사용하고 있는 모든 라우터에 → **링크 상태 정보를 전송**하는 과정

- 수신 링크를 제외한 나머지 모든 링크로 **패킷을 단순하게 복사 전송**하는 **무제어 포트 배정**
- `링크 상태 패킷(LSP: Link State Packet)`을 사용하여 정보 전송
  - LSP 구성: LSP 생성 라우터 ID, 목적지 주소, 비용, 이웃 라우터 ID
- `링크 상태 DB(Link State Database)`
  - 모든 라우터는 동일한 네트워크 맵 정보를 보유하며, 이것으로 최적의 경로를 계산
  - 공통의 DB 유지

> [!NOTE]
>
> 플러딩: 전달, 전송이라는 뜻.
>
> - 플로딩할 때 사용하는 패킷: LSP → 내 라우터에서 경로가 바뀌면 이웃에 있는 라우터에게 전달해줌. 그 때 사용하는 패킷.
> - 무제어 포트 배정: 그냥 다 전달해준다.
>
> 네트워크 변화가 되었다면 이웃에게 전달해줘야 함. → 플로딩 과정을 통해 전달해준다.
>
> ---
>
> A → B로 가는 데 3이 걸리고, A → C로 가는데 7이 걸림
>
> A는 “광고자”라고 함. 이웃 라우터들에게 전달해줌.
>
> 광고자 A 라우터에서 B 라우터 가는데 비용이 3이 들었다.
>
> B, C가 광고자가 되면.. → 모든 라우터가 광고자가 됐을 때 비용이 얼만큼 드는지 따져놓음
>
> 모든 라우터들은 LS DB에 맵 정보를 저장하기 때문에 → 이걸로 최단 거리 계산
>
> 자신이 광고자가 됐을 때, cost가 가장 적게 드는 걸 계산

## ✅ OSPF (Open Shortest Path First, 공개 최단경로 프로토콜)

### 동작

멀티캐스팅: 1110이 멀티캐스팅을 알려주는 신호.

## ✅ 라우팅 프로토콜 (Routing Protocol)

고속 라우팅이 가능. 정적 라우팅은 사용하지 않고 동적 라우팅을 사용

<br />

# 05 BGP (Border Gateway Protocol)

- 자율시스템(AS, Autonomous System) 사이에서 라우팅 정보를 전달
  - 초기에는 전체 라우팅 테이블을 교환, 이후에는 변경된 라우팅 테이블만 교환
  - 목적지에 대한 모든 경로를 보유
  - 갱신 메시지에는 최적의 경로만 전송
- 자율시스템(AS, Autonomous System) 상호 간 적용되는 라우팅 프로토콜(Inter-Domain Routing Protocol)
  - 독립적으로 운용되는 **대규모 네트워크**에서 / 주로 사용되는 라우팅 프로토콜
- 자율시스템(AS, Autonomous System) 상호 간 **정보 교환**을 위한 라우팅 프로토콜
  - EGP(Exterior Gateway Protocol) 또는 IGP(Inter-Domain Routing Protocol)
  - 물리적인 라우터 간에 라우팅하는 관점이 아니라, AS 간에 라우팅이 이루어짐
- 인터넷을 자율시스템(AS, Autonomous System) 간 연결 경로(Path)로 이루어진 방향성 그래프 집단으로 봄
- 무한루프 문제점 방지
  - BGP는 Looping-free하는 라우팅 보장
- peer 관계 설정 / 네트워크 정보생성, 전달이 분리됨
  - 신뢰할 만한 TCP 연결에 의해 라우팅 정보 교환
- Class 없는 주소체계 지원

> [!NOTE]
>
> - 피어(peer) 관계: 동등한 관계
>   - 인증 서버를 두자: 100개의 ID와 PW를 저장. 만약 100번째 컴퓨터가 A에 접속하려고 하면 A의 ID와 PW를 입력해서 연결
>   - 서버의 역할은 인증 서버. 모든 컴퓨터들은 서버를 통해 인증을 받고 연결
>   - → Client/Server 환경
> - 클래스가 없어 CIRD를 지원해 준다

## ✅ BGP 동작 과정

- 경로 설정

  - TCP well-known 포트 179번 사용하여 이웃 노드 간 연결 유지, 갱신 정보 교환
  - keep alive 메시지를 주기적으로 교환해 상대방의 동작 유무에 대한 정보를 얻음
    - keep alive: 세션 또는 상대 노드의 생존 여부를 확인하는 매커니즘

- 연결
  - AS 내부에 BGP 라우팅 프로토콜을 사용하는 라우터가 여러 개 있을 수 있음

> [!NOTE]
>
> Keep-alive 메시지: 해당되는 노드가 살아있다
> kepp alive 메시지는 RIP의 hello 메시지와 비슷함.

### ✔️ 메세지의 종류

1️⃣ **OPEN**

- TCP 3way-HandShake 후 → BGP의 다른 라우터와 이웃관계 설정 시 사용
- TCP 연결이 성립되면 → 관련 파라미터의 협상을 위해 보냄
- OPEN을 거절
  - 중복된 연결 발견 or 버전이 다른 경우
  - NOTIFICATION 메시지에 원인 알리고 연결 종료
- 연결 설정 시
  - KEEPALIVE 메시지 전송하여 연결 설정을 알림

**2️⃣ UPDATE**

- 경로 변동 시 전송
- 새로운 경로가 더 짧은 경우 → 라우팅 테이블 값 대체

3️⃣ **KEEPALIVE**

- OPEN 메시지에 대한 수신확인 메시지
- BGP 이웃이 여전히 살아있는지 알기 위해 주기적으로 전송

4️⃣ **NOTIFICATION**

- BGP 이웃에 오류 상태 알림
- 송신자가 BGP 세션을 종료하고자 할 경우
