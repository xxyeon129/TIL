> [!NOTE]
>
> - Dynamic IP(동적 IP): 접속할 때마다 IP가 바뀜. 공인IP에 속함. IP가 바뀌니까 서버 구축은 안된다
> - (공유기를 사용한) 내부 IP: NAP(Network Address Translation; 네트워크 주소 결정). 내부에서만 사용하는 IP. 비공인IP.
> - IP는 컴퓨터의 주소를 지정하는 것. IPv4와 IPv6가 있음 v는 version을 의미.

<br />

# 01 IPv6 개요

IPv4: _ . _ . * . *라고 할 때 앞 3바이트는 네트워크, 뒤 1바이트는 호스트

## IPv4의 한계

- IP 주소 수요 증가로 → **주소 고갈 문제** 발생
- **Class 단위 주소 할당 방식**으로 인한 → **주소의 낭비**
- 다양한 서비스 제공, 보안 기술 등 **새로운 요구 사항 등장**

## IPv6의 등장

- 기존 IPv4의 32비트 주소길이를 **4배 확장한 128비트** 주소 길이를 사용
- **보안, 라우팅 효율성 문제**, ⭐ **QoS(Quality of Service) 보장**, 무선
- 인터넷 지원 등 다양한 기능들 제공

<br />

# 02 IPv6 특징 (5)

## 1️⃣ 확장된 주소 공간

- 128비트의 주소 공간
  - IPv4 주소 부족 문제를 해결할 수 있을 만큼의 주소공간
  - NAT(Network Address Translation)와 같은 **주소 변환 기술도 불**필요
- `유니캐스트(Unicast)`, `애니캐스트(Anycast)`, `멀티캐스트(Multicast)` 주소 형태
- 주소 자동 생성 기능을 지원
  - IPv4=**10진수** 표기, 8bit\*4=32bit
  - IPv6=**16진수** 표기, 16bit\*8=128bit

## 2️⃣ 새로운 헤더 포맷

- IPv4의 **일부 헤더 필드를 삭제하고 `확장 헤더`를 도입**
  - 패킷을 중계하는 라우터들의 부하를 줄임
- IPv4의 **가변길이 헤더를 고정 길이로 변경**
  - IPv4의 가변길이 패킷과의 호환을 위해 확장헤더 사용
- **패킷 단편화 관련 필드 삭제**
  - 라우터의 부담을 줄이고, 네트워크의 효율적 이용
  - 경로 MTU(Maximum Transmission Unit, 최대전송단위) 탐색 기능 사용
- 헤더의 **체크섬(checksum) 필드 삭제**

## 3️⃣ 향상된 서비스의 지원

- **응용 프로그램의 특정 서비스 품질(QoS) 요구**
  - 실시간 트래픽 및 비실시간 트래픽 구분
- **IPv6 헤더 내에 `플로우 레이블(Flow Label)` 필드 정의**
  - 트래픽 플로우에 대한 구분을 수행
  - 실시간 서비스 등과 같은 우선권을 주기 위해 → 특정 트래픽 플로우에 대한 라벨링

## 4️⃣ 보안 기능

- IPv6는 프로토콜 내에 **보안 관련 기능을 탑재**
  - ⭐ **IPSec(Internet Protocol Security)**
  - 보안과 관련된 인증 절차, 데이터 무결성 보호, 메시지의 발신지 확인 등 기능 제공
    - 데이터 무결성(Data Integrity): 시스템에 있는 데이터의 정확성, 완전성, 일관성
  - IPv6 **확장 헤더**를 이용해 **네트워크 계층에서의 종단간 암호화** 제공
  - InfoSec, IPSec (Security) 이라고도 함

## 5️⃣ 주소 자동설정

> [!NOTE]
> 네트워크를 1로 만들어주는 값 = subnet mask
>
> - 네트워크를 구분해줌
> - 네트워크 1111.1111.1111.0000 → 10진수로 표현하면 255.255.255.0
> - `/24` → prefix
> - CIRD: 클래스 없는 할당 방식

- LAN상의 **MAC(Medium Access Control) 주소**와 + (라우터가 제공하는) **네트워크 prefix**를 결합하여 → **IP 주소 자동설정**
- ✨ 시스템 관리나 설정에 필요한 **비용과 시간을 줄여줌**
- ✨ **사용자에게 편리함** 제공
  - ex. 이동형 컴퓨터에서 어느 곳에서든 네트워크와 연결을 하면 자동으로 포워딩 주소 설정

### 상태 보존형 자동설정 (Stateful auto-configuration): 상태 기반

- DHCP(Dynamic Host Configuration Protocol): 서버로부터 주소를 비롯한 **모든 네트워크 정보를 얻음**
- ✨ 주소의 **이용 효율성** 향상
- ✨ 호스트의 인증과정 등을 이용하여 **보안성 유지**
- 💩 서버의 **설치 및 구성**과 **관리가 복잡**
- 💩 **대규모의 데이터베이스**를 구축

### 비상태형 자동설정(Stateless auto-coniguration)

- **호스트 측에서 스스로 주소를 생성**
- 호스트가 자신의 인터페이스 정보와 라우터로부터 얻은 네트워크 프리픽스 정보 또는 well-known 프리픽스 정보를 이용하여 **자체적으로 IPv6 주소 생성**
- ✨ 특별한 **서버가 필요 없음**
- 💩 이용 권한 없는 호스트의 접근 등으로 인한 **보안 관련 문제**

<br />

# 03 IPv6 주소

## ✅ 주소 표기

16진수 콜론 표기법

128bit → 16bit씩 8개 필드로 나누어 `콜론(:)`으로 구분

## ✅ 주소 생략법

0의 값을 포함하는 주소에 대한 주소 생략법

- 각 필드에서 선행하는 0은 생략 (0221 → 221, 00AB → A, 0000 → 0)
  - 단, 뒤에 나오는 0은 생략 불가
- 0으로만 나타난 연속된 필드는 0을 모두 삭제하고 / 2개의 콜론(이중콜론)만으로 나타냄
  - `::` 기호를 사용하는 경우 → 주소당 한 번만 허용
  - `::`는 주소 내 선행,수행 관계없이 사용
- IPv6 + IPv4 함께 표현하는 경우
  - x:x:x:x:x:x:d.d.d.d
  - 하위 32bit를 IPv4 형식으로 표기

## ✅ 주소 프리픽스 표현 방법

(prefix: 전두사, suffix: 접미사)

IPv6 주소 뒤에 `/`를 표기하고, prefix의 길이를 10진수의 숫자로 표기

## ✅ 주소 형태

### ✔️ 유니캐스트(Unicast) 주소

1:1 통신 시 서로 간의 인터페이스를 식별하는 주소

### ✔️ 글로벌 유니캐스트 주소

- 인터넷 상의 호스트를 구별할 수 있는 **세계적으로 유일한 주소**
- 첫 세 비트가 000으로 시작되는 경우
  - 인터페이스 ID 필드의 크기가 고정되어 있지 않음
- 첫 세 비트가 000으로 시작되지 않는 경우
  - 64bit의 인터페이스 ID 필드
  - 통합 글로벌 IPv6 유니캐스트 주소

### ✔️ 로컬 유니캐스트 주소

- 글로벌에 주소에 대한 절약과 특정 사이트 내에서의 **보안문제를 위해 → 해당 사이트에서만 사용**
- 인터넷 상에서는 사용 불가. 로컬 사이트 내에서만 사용

### ✔️ 멀티캐스트 주소

- **인터페이스 그룹을 식별**하는 주소
  - 임의의 멀티캐스트 주소로 패킷을 전송하는 경우 → 해당 멀티캐스트 그룹에 등록된 모든 호스트가 패킷을 받음
- 동일한 물리적 네트워크에 연결되어 있지 않는 경우에도 패킷 전달
- 상위 8bit는 모두 1로 되어있음
- 동일한 prefix 공유 여부와는 무관

### ✔️ 예약된 멀티캐스트 주소

멀티캐스트 그룹에 할당되어서는 안 되는, 이미 정해져 있는 주소

- 모든 **노드** 멀티캐스트 주소**(flag)**: 해당되는 범위 내의 모든 IPv6 노드를 식별하는 주소
- 모든 **라우터** 멀티캐스트 주소**(scope)**: 해당되는 범위 내 모든 IPv6 라우터를 식별하는 주소

### ✔️ 애니캐스트 주소

- 해당 그룹에 속하는 인터페이스 중 가장 가까운 거리
  - 라우팅 프로토콜에 의해 설정되는 네트워크상의 가장 짧은 거리에 있는 인터페이스에게만 패킷이 전달
- 서브 네트워크상의 가장 가까운 자원을 찾아내기 위한 수단으로도 사용
- 호스트의 주소 및 발신지의 주소로 사용될 수 X

### ✔️ 미지정(Unspectified) 주소

- 0:0:0:0:0:0 혹은 ::
- 노드가 자신의 주소를 알 수 없을 때 이를 알아내기 위해 사용
  - 미지정 주소를 발신지 주소필드에 사용하여 → 자신의 주소를 얻음
- 목적지 주소로 사용 불가능하며, 어떠한 노드에도 할당되지 않음

### ✔️ 루프백(loopback) 주소

- 0:0:0:0:0:0:0:1 혹은 ::1
- IPv4의 127.0.0.1(http://localhost.com)과 같음
- 호스트의 주소 및 발신지의 주소로 사용될 수 없음

### ✔️ IPv4 주소를 포함한 IPv6 주소

- IPv4 호환 주소
- IPv6 패킷이 IPv4 패킷을 경유하고자 할 때
- 128 비트 중 상위 96비트를 0으로 하고 나머지 32bit를 IPv4 주소로 사용

### ✔️ IPv4 매핑 주소

- 호스트가 IPv6를 지원하지 않는 경우 → IPv6 네트워크에서 IPv4 호스트를 식별하기 위한 주소
- IPv4 호스트들의 주소를 → IPv6 주소로 변환할 때 사용하는 주소
- 상위 80비트를 0으로 하고
  다음 16bit를 1로, 나머지 32bit를 IPv4 주소로 사용

> [!NOTE]
> 로컬 유니캐스트 주소: 인터넷에서 사용할 수 없고 자기자신만 테스트해볼 수 있는 주소
> 멀티캐스트 주소 scope 범위
>
> 애니캐스트는 one-to-many.
> 가장 가까운 놈한테 보내주는 것
> (멀티캐스트는 자신에 속해 있는 놈에도. 다른 그룹에 있는 놈들에도 보낼 수 있음)

<br />

# 04 IPv6 패킷

## ✅ 기본 구조

- 기본 헤더: 40byte 고정 크기
- 확장 헤더: 데이터 전송 시 특정 기능(인증)을 사용할 때 추가
- 상위 계층의 PUU: TCP segment 혹은 UDP 메시지 확인
- payload 필드: 확장헤더 + 상위계층의 PUD → 전체데이터량

### 1️⃣ 기본 헤더

- **버전 필드**
- **트래픽 Class**: IPv6 패킷의 Class나 우선순위를 나타냄
- ⭐ **플로우 레이블**
  - 네트워크 상에서 **패킷들의 어떤 특정한 흐름**에 대한 특성을 나타내는 필드
  - 기본값 0, 음성이나 화상 등 **실시간 데이터의 트래픽**을 나타내기 위해 → 0이 아닌 값으로 설정
- **Payload 길이 필드**
- **다음 헤더(Next Header) 필드:** 다음에 어떤 종류의 확장헤더가 오는지 나타내는 필드
- **홉 제한 필드**
  - IP 패킷이 전송되는 거리를 홉 단위로 제한할 때 사용하는 필드
  - 헤더 생성 시 임의의 초기값으로 설정, 라우터를 지날 때마다 값을 -1 감소시켜 홉 제한값이 0이 되면 → 패킷을 폐기
  - 라우팅 루프 방지 위해 → 홉 카운트 주고, 멀티캐스트 그룹 내 가장 가까운 서버를 찾는 것에 이용
- **발신지, 목적지 주소 필드**

### 2️⃣ 확장 헤더

기본적인 기능 외 + **추가적인 기능들을 지원**

다음 헤더(Next Header) 필드로부터 **다음 확장 헤더를 식별**

확장 헤더는 IPv6 패킷 내에 없거나 하나 이상 존재

### ✔️ 홉-바이-홉 옵션 헤더

패킷이 전달되는 경로 상 **모든 라우터가 검사해야 하는 옵션 정보** 전달

- **Pad 1 옵션:** 헤더 내 1byte의 padding을 삽입하기 위해 사용
- **Pad N 옵션:** 두 byte 이상의 padding을 삽입하기 위해 사용
- **점보 Payload 옵션**
  - 패킷 길이가 제한됨에 따라 이 이상 길이를 갖는 패킷을 보내기 위해 사용되는 옵션

### ✔️ 목적지 옵션 헤더

최종 목적지 노드에서**만** 검사

### ⭐ ✔️ 라우팅 헤더

**패킷의 라우팅 경로에 대한 제어**를 하는 필드

IPv4의 **느슨한 소스 라우팅 기능**과 비슷함 → **경로의 일부만 미리 설정**

- source routing 형태
  - **strict source routing:** 송신자가 IP 데이터그램이 통과하는 **정확한 경로**를 지정
  - **loose source routing:** 송신자는 데이터그램이 **경유하는 IP 주소 목록** 지정
    - 경우에 따라 **지정하지 않은 주소를 갖는 라우터를 지날 수 있음**

### ✔️ 분할 헤더

- 최대 전송 단위 MTU(Maximum Transmission Unit)보다 **크기가 큰 패킷**을 목적지까지 전송할 때 사용
- IPv6에서는 **발신 노드에서만 패킷에 대한 분할이 가능**
  - 중간 라우터들은 패킷분할을 할 수 없기 때문에 → 분할 헤더 방식이 필요

### ✔️ 인증 헤더

송신 측에서 전송된 패킷이 전송 도중에 변경되거나 변조되지 않았는지 확인하여 → 확실한 데이터 수신여부를 확인하기 위한 헤더

> [!NOTE]
> IPv6 헤더의 크기는 40바이트.
>
> 40바이트 안에 보면 이런 값들이 다 들어가 있음 여기서 가장 중요한게 ⭐ 플로우 레이블
>
> 인증할 때 사용: 다른 사람이 보낸 게 아니라 내가 보냈다는 것을 확인할 때 사용
>
> 페이로드: 전송할 데이터들.
>
> 트래픽 클래스: 패킷의 클래스나 우선순위를 나타내준다.
> ⭐ 플로우 레이블 필드: 음성이나 화상이다. 아니면 실시간으로 보내는 거라는 걸 알 수 있음
>
> 라우팅에 루프가 발생(자기자신에게 다시 되돌아감) → 방지하기 위해 홉 카운트를 준다
>
> 확장헤더는 없을 수도 있고 하나 이상 존재할 수 있다.
>
> IPv6 왜 도입했느냐 → IP 주소가 모잘랐다. 부족했다. 그리고 공간을 관리하는게 복잡했다. 클래스 단위로 관리하다보니 IP주소 낭비가 많이 생겼다. 그래서 이걸 잘 계획하기 위해 IPv6를 도입했다.
> P2P(peer to peer)에도 많이 사용하고, 모빌리티(이동성) 모바일 쪽에 사용. 안정성-인증 서비스에 적용할 수 있다.

<br />

# 05 IPv4 / IPv6 연동 방법

이중 스택, 터널링, IPv4/IPv6 변환

## ✅ 이중 스택

한 장비에 IPv4와 IPv6를 동시에 운용

(IPv4, IPv6 프로토콜이 모두 탑재되어 있고 / 통신 상대에 따라 해당 IP 스택을 선택하는 시스템)

- 이중 스택 시스템의 주소 설정
  - IPv4: DHCP 기술 사용
  - IPv6 주소: 상태 보존형 주소 자동 설정
- 이중 스택 시스템의 DNS 이름 해석
  - DNS 주소해석 라이브러리가 A 레코드(IPv4), AAAA 레코드(IPv6) 모두 처리
    - A 레코드: IPv4 주소 해당하는 호스트 이름 확인
    - AAAA 레코드: IPv6 주소 해당하는 도메인 이름 확인
- **동적주소 자동 설정**
  - 상태 보존형 주소 자동설정: DHCP 서버 도움받음
  - 상태 비보존형 주소 자동설정 (IPv6만 해당)
    - DHCP 서버 도움 없이도 라우터 도움만으로 주소 설정이 가능

## ✅ 터널링

**데이터 스트림**을 → 인터넷 상에서 **가상의 파이프를 통해 전달**하는 기술

프로토콜의 **패킷을 → 다른 프로토콜의 패킷 안에** **캡슐화**하여 통신

전환 초기에 IPv4 Cloud 안에 IPv6 Tunnel 생성

전환 마무리 단계에 IPv6 Cloud 안에 IPv4

### ✔️ 설정 터널링

- 출발지/목적지 호스트가 `IPv6 호환 주소`**를 인식하지 못할 때**
- **메뉴얼을 통한 정적 터널링**
- 6 Bone(IPv6 백본)에서 사용

### ⭐ ✔️ 자동 터널링

- **`IPv4 호환 주소`**를 이용한 동적 터널링
- **`6 to 4 터널링 방식`**: IPv6 헤더의 목적지 주소에서 → 터널링 목적지로 사용할 수 있는 IPv4 주소를 구하는 것
- **`ISATAP`**(Intra-Site Automatic Tunnel Addressing Protocol) 방식:
  (IPv4 네트워크 위에 있는) 이중 스택 노드 간에 / IPv6 패킷을 전송하기 위한 → **IPv6 전환 매커니즘**

## ✅ IPv4/IPv6 변환

IPv4-IPv6 **게이트웨이**를 통해 / 서로 다른 네트워크 상의 **패킷을 변환**

IPv4 헤더와 IPv6 헤더를 상호 변환

> [!NOTE]
> 이중스택, 터널링, IPv4/IPv6 변환(정적변환, 자동설정)
>
> IPv6에 있는 놈을 갖다가 IPv4로 보내줄 수 있다
