# 01 SQL 개요

SQL(Structured Query Language)

- **관계형 데이터베이스 표준 언어로서 가장 많이 사용되는 데이터 언어**
- ORACLE, MS SQL-Server, MySQL 등 거의 모든 관계형 DBMS가 지원

### SQL을 구성하는 3가지 부속 언어

- **데이터 정의어(DDL; Data Definition Language)**
  - DB 구조 정의
  - DB 객체 생성/수정/삭제 (테이블, 뷰, 인덱스 등)
- **데이터 조작어(DML; Data Manipulation Language)**
  - DB 데이터 관리
  - 입력/수정/삭제/검색
- **데이터 제어어(DCL; Data Control Language)**
  - DB 관리 및 통제
  - DB 백업/복원
  - 사용자 등록/권한 관리

<br />

# 02 SQL 실습 준비

‘univ’ 데이터베이스 스키마

- 학생(**학번**, 이름, 주소, 학년, 나이, 성별, 휴대폰번호, 소속학과)
- 수강(**학번, 과목번호**, 신청날짜, 중간성적, 기말성적, 평가학점)
- 과목(**과목번호**, 이름, 강의실, 개설학과, 시수)

## MySQL

- 세계에서 가장 많이 사용하는 오픈소스 RDBMS
- 코드가 공개되어 있어 누구나 다운로드하여 사용할 수 있는 데이터베이스 관리 시스템
- 무료임에도 처리 속도가 빠르고 설치도 쉬움
- 오라클, MS-SQL Server와 함께 가장 많이 사용하는 DBMS 중 하나

1. MySQL 서버를 미리 구동 → 클라이언트 관리 도구인 MySQL 워크벤치 실행
2. 슈퍼 사용자 root로 접속
3. MySQL 버전, 시스템 날짜 시간 정보 확인

   ```sql
   SELECT version(); --MySQL 버전 표시
   SELECT current_date(), current_time(), now(); --현재 날짜와 시간 표시
   ```

4. 현재 접속한 사용자 아이디 확인

```sql
SELECT user(); -- 현재 MySQL 사용자 표시
```

5. 데이터베이스 목록 확인

   ```sql
   SHOW DATABASES; -- 현재 데이터베이스 목록 표시
   ```

6. ‘univDB’ 실습 예제 데이터베이스 생성

   ```sql
   -- DB 생성
   DROP DATABASE IF EXISTS univDB;
   CREATE DATABASE IF NOT EXISTS univDB;

   -- univDB가 생성되었는지 확인
   SHOW databases;

   -- SQL 명령어를 실행할 대상인 기본 DB를 univDB로 지정
   USE univDB;

   -- 현재 사용 DB 확인
   SELECT database();

   -- 학생 테이블 생성
   CREATE TABLE 학생
     ( 학번 CHAR(4) NOT NULL,
       이름 VARCHAR(20) NOT NULL,
       주소 VARCHAR(50) NULL DEFAULT '미정',
       학년 INT NOT NULL,
       나이 INT NOT NULL,
       성별 CHAR(1) NOT NULL,
       휴대폰번호 CHAR(14) NULL,
       소속학과 VARCHAR(20) NULL,
       PRIMARY KEY (학번) );

   -- 학생 테이블 입력
   INSERT INTO 학생
   VALUES('s001', '김연아', '서울 서초', 4, 23, '여', '010-1111-2222', '컴퓨터');
   INSERT INTO 학생
   VALUES('s002', '홍길동', DEFAULT, 1, 26, '남', NULL, '통계');

   -- univDB 안의 생성 테이블 목록 확인
   SHOW TABLES;

   -- 학생 테이블 생성 정보 확인
   DESC 학생;
   ```

<br />

# 03 SQL 데이터 조작문

- 데이터 검색: `SELECT`
- 데이터 삽입: `INSERT`
- 데이터 수정: `UPDATE`
- 데이터 삭제: `DELETE`

## 1️⃣ 데이터 검색 SELECT문

행 검색 → 테이블로부터 데이터를 검색

- 형식: `SELECT`절, `FROM`절
  - SELECT 명령문의 형식
  - `[ ]`로 표시한 부분은 생략 가능, `{ }`로 표시한 부분은 반복 가능
  - `|`는 선택을, `+`는 1번 이상 반복을, `*`는 0번 이상 반복을 의미

```sql
SELECT [DISTINCT | ALL] 열_리스트
FROM 테이블_리스트
[WHERE 검색_조건식]
[GROUP BY 그룹_기준열_리스트]
[HAVING 그룹_조건식]
[ORDER BY {정열_기준열 [ASC|DESC][,] }+ ];
```

```sql
SELECT 제조업체
FROM 제품;

// 제품 테이블에서 제품명과 단가 속성을 검색하되, 단가에 500원 더해 '조정 단가' 새 이름 출력
SELECT 제품명, 단가 + 500 AS "조정 단가"
FROM 제품
```

### ✔️ 조건 검색: WHERE절

```sql
// 1,2,3학년이거나 소속학과가 '컴퓨터'학과가 아닌 학생의 이름, 학년, 소속학과 검색
SELECT 이름, 학년, 소속학과
FROM 학생
WHERE (학년>=1 AND 학년<=3) OR NOT(소속학과='컴퓨터');
// 학년 BETWEEN 1 AND 3
```

​

### ✔️ 정렬 검색: ORDER BY

- 오름차순(기본): ASC
  - NULL값 맨 마지막 출력
- 내림차순: DESC
  - NULL값 맨 먼저 출력

```sql
// 주문 테이블에서 수량이 10개 이상인 주문의 주문고객, 주문제품, 수량을 검색
// 주문제품을 기준으로 오름차순 정렬, 동일 제품은 수량을 기준으로 내림차순 정렬
SELECT 주문고객, 주문제품, 수량
FROM 주문
WHERE 수량>=10
ORDER BY 주문제품 ASC, 수량 DESC
```

### ✔️ 집계 함수 검색

집계 함수: 각 열에 대한 기본 통계 결과를 반환하는 함수

- 실제 테이블 저장 값이 아닌, 행의 개수(count) 또는 특정 열의 값 평균(average)을 구하는 질의가 필요할 경우를 위해 SQL은 집계 함수를 제공
- **`COUNT**(열\_이름)`
  - NULL 속성값은 제외하고 개수 계산
  - 정확한 개수를 계산하기 위해서는 보통 기본키 속성이나 \*를 주로 이용

```sql
// 고객 테이블에 고객이 몇 명 등록되어 있는지 검색
SELECT COUNT(고객아이디) AS 고객수
FROM 고객;

SELECT COUNT(*) AS 고객수
FROM 고객;

// 제품 테이블에서 제조업체 수 검색 (중복X)
SELECT COUNT(DISTINCT 제조업체) AS "제조업체 수"
FROM 제품;
```

- **`MAX**(열\_이름)`
- **`MIN**(열\_이름)`
- **`SUM**(열\_이름)`

  ```sql
  // 한빛제과에서 제조한 제품의 재고량 합계 (제품 테이블)
  SELECT SUM(재고량) AS "재고량 합계"
  FROM 제품
  WHERE 제조업체='한빛제과';
  ```

- **`AVG**(열\_이름)`

  ```sql
  // 제품 테이블에서 모든 제품의 단가 평균
  SELECT AVG(단가)
  FROM 제품;

  // '여'학생의 평균 나이 검색
  SELECT AVG(나이) '여학생 평균나이'
  FROM 학생
  WHERE 성별='여';
  ```

### ✔️ 그룹별 검색: `GROUP BY`, `HAVING`

- **`GROUP BY`**: 특정 속성의 **값이 같은** 투플을 모아 그룹을 만들고, 그룹별로 검색
- **`HAVING`**: 그룹에 대한 조건 작성
  - 그룹이 만족해야 하는 제한 조건
  - **집계 함수를 이용한 조건**은 WHERE절에는 작성할 수 없고, HAVING절에서 작성 가능
  - `WHERE`절이 행에 대한 ‘검색*조건식’을 명세한다면, `HAVING`절은 행 그룹에 대한 ‘그룹*조건식’을 명세
- 그룹을 나누는 기준이 되는 속성을 SELECT절에도 작성하는 것이 좋음

```sql
// 주문 테이블에서 주문제품별 수량의 합계 검색
SELECT 주문제품, SUM(수량) AS 총주문수량
FROM 주문
GROUP BY 주문제품;

// 제품 테이블에서 제조업체별로 제조한 제품의 개수와 제품 중 가장 비싼 단가 검색
// 제품의 개수는 제품수라는 이름으로 출력
// 가장 비싼 단가는 최고가라는 이름으로 출력
SELECT 제조업체, COUNT(*) AS 제품수,  MAX(단가) AS 최고가
FROM 제품
GROUP BY 제조업체;

// 제품 테이블에서 제품을 3개 이상 제조한 제조업체별로
// 제품의 개수와 제품 중 가장 비싼 단가 검색
SELECT 제조업체, COUNT(*) AS 제품수, MAX(단가) AS 최고가
FROM 제품
GROUP BY 제조업체 HAVING COUNT(*) >= 3;

// 고객 테이블에서 적립금 평균이 1000원 이상인 등급에 대해
// 등급별 고객수와 적립금 평균 검색
SELECT 등급, COUNT(*) AS 고객수, AVG(적립금) AS "적립금 평균"
FROM 고객
GROUP BY 등급 HAVING AVG(적립금) >= 1000;

// 주문 테이블에서 각 주문고객이 주문한 제품의 총주문수량을 주문제품별로 검색
SELECT 주문제품, 주문고객, SUM(수량) AS 총주문수량
FROM 주문
GROUP BY 주문제품, 주문고객;

// 20대 학생만을 대상으로 나이별 학생수를 검색
SELECT 나이, COUNT(*) AS '나이별 학생수'
FROM 학생
WHERE 나이>=20 and 나이<30
GROUP BY 나이;

// 각 학년별로 2명 이상의 학생을 갖는 학년에 대해서만 학년별 학생수 검색
SELECT 학년, COUNT(*) AS "학년별 학생수"
FROM 학생
GROUP BY 학년 HAVING COUNT(*) >= 2;
```

### ✔️ LIKE 문자 연산자 검색 (`_`, `%` 와일드카드 )

- 부분 문자열(substring) 포함 여부를 검색하기 위해 **`WHERE`절 검색\_조건식**에 사용되는 비교 연산자
- 검색 문자열 값을 정확히 모르거나 일부만 알고 있는 경우
- `_`: 문자열 중 특정 위치에 **1개**의 모든 문자를 허용
- `%`: 문자열 중 임의 위치에 **0개 이상**의 모든 문자(열)를 허용

| 적용 예      | 검색 일치           | 검색 불일치      |
| ------------ | ------------------- | ---------------- |
| LIKE ’\_ook’ | book, look          | good, books, ook |
| LIKE ‘9_7_5’ | 98765, 91715, 9a7b5 | 975, 98754       |
| LIKE ‘%k’    | book, milk, ok, k   | books            |
| LIKE ‘b%k’   | book, bblack, bk    | kbkbk, bbooks    |

```sql
// 고객 테이블에서 성이 김 씨인 고객의 고객이름, 나이, 등급, 적립금 검색
SELECT 고객이름, 나이, 등급, 적립금
FROM 고객
WHERE 고객이름 LIKE '김%';

// 고객 테이블에서 고객 아이디가 5자인 고객의 고객아이디, 고객이름, 등급 검색
SELECT 고객아이디, 고객이름, 등급
FROM 고객
WHERE 고객아이디 LIKE '_____';

// 주소지가 '서울'인 학생의 이름, 주소, 학년을 학년 순(내림차순)으로 검색
SELECT 이름, 주소, 학년
FROM 학생
WHERE 주소 LIKE '%서울%'
ORDER BY 학년 DESC;
```

### ✔️ 널 값 검색: `IS NULL`, `IS NOT NULL`

- `=` 비교 연산자 사용 불가
- NULL이 포함된 행은 대부분의 집계 함수 결과에서 제외됨
- ‘100 <> NULL’ 처럼 널값을 일반 비교연산자로 비교하면 결과는 항상 거짓(false)

```sql
// 휴대폰 번호가 등록되지 않은(NULL값을 갖는) 학생의 이름과 휴대폰번호 검색
SELECT 이름, 휴대폰번호
FROM 학생
WHERE 휴대폰번호 IS NULL;

// 고객 테이블에서 나이가 이미 입력된 고객의 고객이름 검색
SELECT 고객이름
FROM 고객
WHERE 나이 IS NOT NULL;
```

### ✔️ 집합 연산자를 이용한 검색: `UNION`

UNION(합집합) 연산자

- 여러 SELECT 명령문의 검색 결과를 결합
- 결과 테이블에서 자동으로 **중복 행을 제거한 나머지 행**들을 반환
- MySQL은 INTERSECT(교집합), EXCEPT, MINUS(차집합) 연산자를 지원하지 않음

```sql
// '여'학생이거나 'A'학점을 받은 학생의 학번을 검색
SELECT 학번
FROM 학생
WHERE 성별='여'
UNION
SELECT 학번
FROM 수강
WHERE 평가학점='A';
```

### ✔️ 부속 질의문을 이용한 검색

부 질의문(subquery)

- 질의문 안에 중첩(nested)되어 포함된 또다른 SELECT 검색문
- 괄호 안의 가장 안쪽 부 질의문부터 먼저 수행되고, 가장 바깥쪽 주 질의문이 가장 나중에 수행됨
- WHERE절의 검색 조건 값을 미리 알지 못하거나 실시간으로 조건식을 완성해야 하는 경우 유용

SELECT 문 안에 또다른 SELECT문을 포함하는 질의

- **상위 질의문(주 질의문)**: 다른 SELECT문을 포함하는 SELECT문
- **부속 질의문(서브 질의문)**: 다른 SELECT문 안에 들어있는 SELECT문

  - 괄호로 묶어서 작성
  - ORDER BY 절을 사용할 수 없음
  - **단일 행 부속 질의문**: 하나의 행을 결과로 반환
    - 비교연산자(=, <>, >, >=, <, <=) 사용 가능
  - **다중 행 부속 질의문**: 하나 이상의 행을 결과로 반환

    - **비교연산자 사용 불가**
    - 사용 가능한 연산자

      - **`IN`**: 나열된 값들 중 **하나라도 일치하는 경우 참(true)**을 반환하는 연산자
      - **`NOT IN`**: 나열된 값들 중 어떤 값도 일치하지 않을 경우 참(true) 반환
      - 여러 값들과의 반복 비교를 위함 → `=`기호를 나열할 필요 없이 한꺼번에 표현

      ```sql
      // 과목번호가 'c002'인 과목을 수강한 학생의 이름을 검색
      SELECT 이름
      FROM 학생
      WHERE 학번 IN ('s001', 's003', 's004');

      // 판매 데이터베이스에서 banana 고객이 주문한 제품의 제품명과 제조업체 검색
      // 주문 테이블, 제품 테이블
      SELECT 제품명, 제조업체
      FROM 제품
      WHERE 제품번호 IN (SELECT 주문제품
      								 FROM 주문
      								 WHERE 주문고객='banana'); // WHERE 제품번호 IN ('p01', 'p04', 'p06')
      ```

      - `EXISTS`: 부속 질의문의 결과 값이 하나라도 존재하면 검색 조건이 참
        ```sql
        // 판매 데이터베이스에서 2022년 3월 15일에 제품을 주문한 고객의 고객이름 검색
        // 주문 테이블, 고객 테이블
        SELECT 고객이름
        FROM 고객
        WHERE EXISTS (SELECT *
        							FROM 주문
        							WHERE 주문일자='2022-03-15'
        										AND 주문.주문고객 = 고객.고객아이디)
        										// 상호연관(상관) 질의문(correlated query)
        ```
      - `NOT EXISTS`: 부속 질의문의 결과 값이 하나도 존재하지 않으면 검색 조건이 참
      - `ALL`: 부속 질의문의 결과 값 모두와 비교한 결과가 참이면 검색 조건을 만족(비교 연산자와 함께 사용)
        ```sql
        // 제품 테이블에서 대한식품이 제조한 모든 제품의 단가보다 비싼 제품의
        // 제품명, 단가, 제조업체 검색
        SELECT 제품명, 단가, 제조업체
        FROM 제품
        WHERE 단가 > ALL (SELECT 단가
        								  FROM 제품
        								  WHERE 제조업체='대한식품');
        ```
      - `ANY` 또는 `SOME`: 부속 질의문의 결과값 중 하나라도 비교한 결과가 참이면 검색 조건을 만족(비교 연산자와 함께 사용)

- 부속 질의문을 먼저 수행하고, 그 결과를 이용해 상위 질의문 수행
- 부속 질의문과 상위 질의문 연결하는 연산자 필요

```sql
// 제품 테이블에서 달콤비스킷을 생산한 제조업체가 만든 제품들의 제품명과 단가 검색
SELECT 제품명, 단가
FROM 제품
WHERE 제조업체 = ( SELECT 제조업체
									FROM 제품
									WHERE 제품명='달콤비스킷');

// 고객 테이블에서 적립금이 가장 많은 고객의 고객이름과 적립금 검색
SELECT 고객이름, 적립금
FROM 고객
WHERE 적립금 = (SELECT MAX(적립금)
							 FROM 고객);

```

- **상호연관(상관) 질의문:**중첩 질의문 중 내부 질의의 WHERE절 검색\_조건식이 외부 질의에 선언된 테이블의 일부 열을 참조하는 질의

### ✔️ 조인 검색: `JOIN`

둘 이상의 테이블로부터 연관된 행들의 결합을 통해 검색 결과 생성

```sql
// 조인 명세 방법1
SELECT 열_리스트
FROM 조인테이블_리스트
WHERE <조인_조건식> AND <검색_조건식>

// 조인 명세 방법2
SELECT 열_리스트
FROM 테이블이름1 {[INNER] JOIN 테이블이름2 ON <조인_조건식>}+
WHERE <검색_조건식>

// 동등 조인
SELECT *
FROM 학생 JOIN 수강 ON 학생.학번=수강.학번

// INNER JOIN과 ON 키워드
SELECT 속성_리스트
FROM 테이블1 INNER JOIN 테이블2 ON 조인조건
[WHERE 검색조건]

// OUTER JOIN과 ON 키워드
SELECT 속성_리스트
FROM 테이블1 LEFT | RIGHT + FULL OUTER JOIN 테이블2 ON 조인조건
[WHERE 검색조건]

// CROSS JOIN -> 카티션 프로덕트 연산 결과 (의미없는 기계적인 결합)
SELECT *
FROM 학생 CROSS JOIN 수강; // FROM 학생, 수강
```

- 조인 속성: 조인 검색을 위해 테이블을 연결해주는 속성
  - 연결하려는 테이블 간 조인 속성의 이름은 달라도 되지만, 도메인은 같아야 함
  - 일반적으로 외래키를 조인 속성으로 이용함
- `FROM`절에 검색에 필요한 모든 테이블을 나열
- `WHERE`절에 조인 속성의 값이 같아야 함을 의미하는 조인 조건 제시
- 속성 이름 앞에 해당 속성이 소속된 테이블 이름 표시
  - 같은 이름의 속성이 서로 다른 테이블에 존재할 수 있음
  - ex. 주문.주문고객

```sql
// 제품, 주문 테이블에서 banana 고객이 주문한 제품의 이름 검색
SELECT 제품.제품명
FROM 제품, 주문
WHERE 주문.주문고객 = 'banana' AND 제품.제품번호=주문.주문제품;

// 제품, 주문, 고객 테이블에서 고명석 고객이 주문한 제품의 제품명 검색
SELECT 제품.제품명
FROM 제품, 주문, 고객
WHERE 고객.고객이름='고명석' AND 고객.고객아이디=주문.주문고객 AND 주문.주문제품=제품.제품번호;

// 학생 중 과목번호가 'c002'인 과목을 수강한 학생의
// 학번과 이름, 과목번호, 변환중간성적(학생별 중간 성적의 10% 가산점수)
SELECT 학생.학번, 이름, 과목번호, 중간성적+(중간성적*0.1) AS 변환중간성적
FROM 학생, 수강
WHERE 학생.학번 = 수강.학번 AND 수강.과목번호='c002';
// FROM 학생 JOIN 수강 ON 학생.학번 = 수강.학번

// 학생 중에서 '정보보호' 과목을 수강한 학생의 학번과 이름, 과목번호 검색
SELECT 학생.학번, 학생.이름, 수강.과목번호
FROM 학생, 수강, 과목
WHERE 학생.학번=수강.학번 AND 수강.과목번호=과목.과목번호 AND 과목.이름='정보보호';
// FROM (학생 JOIN 수강 ON 학생.학번=수강.학번) JOIN 과목 ON 수강.과목번호=과목.과목번호
```

### JOIN > INNER JOIN

```sql
// 주문, 고객 테이블에서 나이가 30세 이상인 고객이 주문한 제품의 번호와 주문일자를 검색
SELECT 주문.주문제품, 주문.주문일자
FROM 주문, 고객
WHERE 고객.나이>=30 AND 고객.고객아이디=주문.주문고객;

// INNER JOIN 사용
SELECT 주문.주문제품, 주문.주문일자
FROM 고객 INNER JOIN 주문 ON 고객.고객아이디=주문.주문고객
WHERE 고객.나이>=30;
```

### JOIN > 테이블 별칭 사용

```sql
// 학생 중에서 과목번호가 'c002'인 과목을 수강한 학생의 이름, 과목번호 검색
SELECT 이름, 과목번호
FROM 학생 AS S, 수강 E
WHERE S.학번=E.학번 AND E.과목번호='c002';
```

### JOIN > 셀프 조인(self join)

```sql
// 주소가 같은 학생들의 이름을 쌍으로 검색
// 검색되는 첫 번째 학생이 두 번째 학생보다 학년이 높도록
SELECT S1.이름, S2.이름
FROM 학생 S1 JOIN 학생 S2 ON S1.주소=S2.주소
WHERE S1.학년 > S2.학년;
```

### JOIN > OUTER JOIN

```sql
// 과목을 수강하지 않은 학생을 포함하여
// 모든 학생의 학번, 이름, 학생이 수강한 교과의 평가학점 검색
SELECT 학생.학번, 학생.이름, 수강.평가학점
FROM 학생 LEFT OUTER JOIN 수강 ON 학생.학번=수강.학번
```

- **`LEFT OUTER JOIN`**: 조인 연산자의 왼쪽 테이블의 모든 행들이 빠짐없이 조인 최종 결과에 포함
- **`RIGHT OUTER JOIN`**: 조인 연산자의 오른쪽 테이블의 모든 행들이 빠짐없이 조인 최종 결과에 포함
- **`FULL OUTER JOIN`**: 조인 연산자의 왼쪽, 오른쪽 테이블 모든 행들이 빠짐없이 조인 최종 결과에 포함

## 2️⃣ 행 삽입 INSERT문

```sql
INSERT INTO 테이블_이름 [(속성_리스트)]
VALUES (속성값_리스트);
```

- 속성 리스트를 생략하면 테이블을 정의할 때 지정한 속성의 순서대로 삽입됨

```sql
// 고객아이디, 고객이름, 나이, 등급, 직업, 적립금
INSERT INTO 고객
VALUES ('strawberry', '최유경', 30, 'vip', NULL, 100);

INSERT INTO 고객(고객아이디, 고객이름, 나이, 등급, 적립금)
VALUES ('strawberry', '최유경', 30, 'vip', 100);

// 검색하여 삽입된 새로운 투플 확인
SELECT * FROM 고객;

// 주소 '미정', 휴대폰번호 NULL
INSERT INTO 학생(학번, 이름, 주소, 학년, 나이, 성별, 휴대폰번호, 소속학과)
VALUES ('g003', '이승엽2', DEFAULT, 3, 30, '남', NULL, '정보통신');
```

### ✔️ 부속 질의문(SELECT)을 이용한 데이터 삽입

```sql
INSERT INTO 테이블_이름[(속성_리스트)]
SELECT 문;
```

```sql
// 한빛제과에서 제조한 제품의 제품명, 재고량, 단가를 제품 테이블에서 검색하여
// 한빛제품 테이블에 삽입

INSERT INTO 한빛제품(제품명, 재고량, 단가)
SELECT 제품명, 재고량, 단가
FROM 제품
WHERE 제조업체='한빛제과';
```

## 3️⃣ 행 수정 UPDATE문

```sql
UPDATE 테이블_이름
SET 속성_이름1=값1, 속성_이름2=값2, ...
[WHERE 조건];
```

- `SET` 키워드 다음에 속성 값을 어떻게 수정할 것인지를 지정
- `WHERE`절을 생략하면 테이블에 존재하는 모든 투플을 대상으로 수정

### ✔️ 단일 행, 단일 열 수정

```sql
// '이은진' 학생의 학년을 '3'학년으로 수정
UPDATE 학생
SET 학년=3
WHERE 이름='이은진';

// 확인
SELECT *
FROM 학생
WHERE 이름='이은진';
```

### ✔️ 복수 행, 복수 열 수정

```sql
// 4학년인 학생의 학년을 1씩 증가시키고 소속학과를 '자유전공학부'로 변경
UPDATE 학생
SET 학년=학년+1, 소속학과='자유전공학부'
WHERE 학년=4;

// 제품 테이블의 모든 제품의 단가를 10% 인상
UPDATE 제품
SET 단가=단가*1.1;
```

### ✔️ 부속 질의문 포함

```sql
// 판매 데이터베이스(고객, 주문 테이블)에서 정소화 고객이 주문한 제품의 주문수량 5개로 수정
UPDATE 주문
SET 수량=5
WHERE 주문고객 IN ( SELECT 고객아이디
									FROM 고객
									WHERE 고객이름='정소화');

// 수강 내용이 없는 학생의 소속학과를 널 값으로 수정
UPDATE 학생
SET 소속학과=NULL
WHERE 학번 NOT IN (SELECT 학번 FROM 수강);
```

### 활용 예제

```sql
// 학번이 's003'인 학생의 수강 내용을 '이은진'학생이 수강한 것으로 수정
// (수강 테이블의 학번을 's003' 대신 '이은진' 학생의 학번으로 변경)
UPDATE 수강
SET 학번=(SELECT 학번
					FROM 학생
					WHERE 이름='이은진')
WHERE 학번='s003';
```

## 4️⃣ 데이터 삭제: DELETE문

```sql
DELETE
FROM 테이블_이름
[WHERE 조건];
```

- `WHERE`절에 제시한 조건을 만족하는 투플만 삭제
- `WHERE`절을 생략하면 테이블에 존재하는 모든 투플을 삭제해 빈 테이블이 됨
  - `DROP TABLE`과는 다름(빈 테이블이 남으므로)

```sql
// 주문 테이블에서 주문일자가 2022년 5월 22일인 주문 내역 삭제
DELETE
FROM 주문
WHERE 주문일자='2022-05-22';

// 판매 데이터베이스의 주문 테이블에 존재하는 모든 투플 삭제
DELETE
FROM 주문;
```

### ✔️ 부 질의문을 이용한 삭제

```sql
// 판매 데이터베이스(고객, 제품 테이블)에서 정소화 고객이 주문한 주문 테이블에서 삭제
DELETE
FROM 주문
WHERE 주문고객아이디 IN (SELECT 고객아이디
												FROM 고객
												WHERE 이름='정소화');

// 수강 테이블의 수강자가 2명 미만인 과목에 대한 과목 테이블의 과목 정보를 모두 삭제
DELETE
FROM 과목
WHERE 과목번호 IN (SELECT 과목번호
                  FROM 수강
                  GROUP BY 과목번호
                  HAVING COUNT(*)<2);
```
