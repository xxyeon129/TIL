# 01 아키텍처 설계

아키텍처 설계: 소프트웨어 개발 시 뼈대를 세우는 것

## ☑️ 아키텍처의 필요성

대규모 소프트웨어 개발 → 복잡성 문제 해결

- 전체 구조 가장 먼저 생각
- 소웨 구조 이루는 각 구성 요소를 찾는다
- 각 구성 요소 간 명확한 관계 설정
- 일정한 규칙을 따름

사용자가 만족할 품질 소웨 개발하려면 → 요구분석, 설계 단계부터 품질 특성을 고려해 개발

→ 따라서 아키텍처 설계 필요

- 비기능 요구사항도 꼼꼼히 살펴봐야 한다

## ☑️ 아키텍처의 특징과 기능

소웨 아키텍처 = 소웨 골격이 되는 기본 구조. 시스템 전체 큰 밑그림

- 소웨 골격을 나타내는 추상화(3가지 → 자료 추상화, .. 추상화, 절차 추상화)된 전체 구조 제공
- 소웨 이루고 있는 여러 구성 요소 (서브 시스템, 컴포넌트) 다룸
- 인터페이스를 통해 소프트웨어의 구성 요소가 어떻게 상호작용하는지를 정의
- ~~세부 내용보다는~~ **중요 내용(설계자가 주관적으로 판단하고 결정)만**
- 설계에 적용되는 원칙, 지침 존재

최상위 수준 아키텍처 설계 → 개발될 소웨 구조 드러냄 but 구현 관련된 **세부 내용은 감춘 채 → 모든 기능 요구사항, 품질 요구사항 최대한 충족되도록**

### 아키텍처 설계를 위해 고려해야 하는 기능

- **모든** 이해관계자 사이 의사소통 도구 활용 가능해야 함
- 구현에 대한 제약 사항(개발 비용, 기간, 조직 역량..) 정의
- **모든** 이해관계자 품질 요구사항 반영 → 우선순위 따라 시스템 품질 속성을 결정
  - 시스템 품질 속성: 성능, 사용성, 보안성, 안정성, 검증 가능성, 변경 용이성 등
  - 기신사 효(효율성)유(유지보수성)이(이식성) 6가지
- 특정 문제 영역에 적합한 소웨 구성 요소 표준화, 패턴화 → 재사용할 수 있도록 설계

### 소웨 아키텍처 설계 효과

- 소웨 기본 골격 만들어져 → 구현상 문제점 도출
- 소웨 아키텍처 기반으로→ 분할 방법 찾고, 구조화 위한 구체적 방안
- 설계 원칙, 가이드 제공, 설계 재사용 가능
- 스웨 아키텍처 기준 개발 조직을 만들 수 있음
- 전사 조직을 소웨 아키텍처에 맞게 재편 가능
- 품질 특성에 대한 → 평가 방법 결정 가능

## ☑️ 아키텍처의 품질 속성 (시6-비6-아3)

**`품질 속성`** → (1. 사용성, 2. 이식성, 3. 유지보수 용이성과 같이) 이해관계자의 요구사항과 관심사 반영한 것

이해관계자들이 **요구하는 수준만큼** 품질 속성을 달성해야 함 → **`품질 요구사항`**

- 품질 요구사항은 가능한 정확한 수치로 제시 → 공허한 부분이 있긴 한데 사용자가 요구하면 만들어야함. 사용자가 요구하는 레벨(사용자가 요구하는 수준)대로
- **아키텍처 설계 시 품질 속성을 반영하는 방법**
  1. 프젝에서 중요하게 생각하는 **품질 속성 결정**
  2. 결정한 품질 속성을 → 어느 정도 수준으로 설계할건지 목표설정
  3. 목표 달성 방법 서술
  4. 품질 속성을 평가할 방법 서술

### 1. 시스템 품질 속성 (6)

- **1) 가용성**
  - 장애 발생 없이 서비스 제공할 수 있는 능력
  - MTTR, MTT.. 지난 시간
  - 가용성 높이기 위한 → `이중화 설계`
    - 클라우드 환경은 대체적으로 이중화가 되어 있다
- **2) 변경 용이성**
  - 사용자가 새로운 요구사항 요청했을 때 → 얼마나 쉽게 변경할 수 있는지
  - 응집도(결합도) 확 낮춰야 함
  - 주석, 추적 용이성 해줘야 함
  - 자주 바뀌는 소웨는 변경 용이성을 쉽게 해야 한다(다른 품질 속성보다 우선으로 고려)
- **3) 성능 performance**
  - 사용자 요청 이벤트 발생했을 때 → 얼마나 빠르고 효율적으로 기능 수행할 수 있는가
  - 성능이 좋고 나쁨: 사용자 요청에 관한 결과를 제공하는 대기시간, 초당 처리할 수 있는 트랜잭션의 수로 표현 (얼마나 빨리 되는지)
  - 공유 자원을 어떻게 사용해서 설계하는지, 어떤 알고리즘 선택하는지가 중요
- **4) 보안성 security**
  - 허용되지 않은 접근에 대응할 수 있는 능력
  - 계층 구조 아키텍처 → 가장 안쪽 계층에 중요한 자료 저장
- **5) 사용성 usability**
  - 초보자의 입장에서 불편을 느끼지 않도록 도움말 기능
  - 예전 엑셀 단축키 위주, 요즘 엑셀은 도움말 많음
- **6) 테스트 용이성 testability**
  - 테스트가 소요되는 비용 얼마나 단축할 수 있는지를 아키텍처 설계에 반영

### 2. 비즈니스 품질 속성 (6)

- **1) 시장 적시성 time to market**
  - 적정한 시기 소프트웨어 출시 → 경쟁력 높이는 것 (비용이 많이 들더라도)
  - 이를 위해 아키텍처 설계를 할 때 → 구매한 컴포넌트들이 잘 맞을 수 있도록 / 범용성 높은 설계가 필요
- **2) 비용과 이익 cost and benefit**
  - 비용 많이 들인 유연한 설계(유지보수 쉬움) vs. 비용 절감해 이익 높이는데 초점(유지보수에 더 큰 비용 들 수 있음)
- **3) 예상 시스템 수명 predicted lifetime of the system**
  - 시스템 사용 기간을 예측해 아키텍처 설계에 반영
  - 계속해서 수정 및 보완, 운영체제나 하드웨어가 바뀔 것도 염두
  - 예상 시스템 수명을 위해서는 → `확장성`, `이식성`과 같은 아키텍처 품질 속성 고려
- **4) 목표 시장 targeted market**
  - `기능성` 매우 중요
  - 다양한 플랫폼에서 잘 작동해야 하므로 → 시스템 품질 속성 중 `이식성` 고려
- **5) 신규 발매(공개) 일정 roll-out schedule**
  - 일정에 개발 못 맞출 경우 → 현재 버전, 이후 배포 차기 버전 기능 추가
  - 아키텍처 설계 시 → `유연성`, `확장성` 고려
- **6) 기존 시스템과의 통합 integration with legacy system**
  - 기존에 사용하던 DBMS나 개발 시 제약 사항 충분히 고려한 아키텍처 설계 필요

### 3. 아키텍처 품질 속성 (3)

- **개념적 무결성 conceptual integrity**
  - = 일관성
  - 세부 구성 요소 → 전체 시스템으로 통합해도 → 일관성 유지
  - 세부, 전체 일관되도록 아키텍처 결정
- **정확성과 완전성 correctness completeness**
  - 사용자 요구 기능 충족시키는 정도 → 요구분석명세서와 일치하는 정도
- **개발 용이성 buildability**
  - = 구축 가능성
  - 전체 시스템을 적절한 모듈로 분할 → 알맞게 분배해서 개발
  - 정해진 기간 내 개발 완성 가능, 개발 과정 중에도 쉽게 변경할 수 있는 능력

## ☑️ 아키텍처의 4+1 관점

논리적 관점, 개발 관점, 프로세스 관점, 물리적 관점

소프트웨어 아키텍처는 UML의 4+1 \*관점을 이용해 설명

- \*관점 → 시스템을 이루는 요소의 집합 + 그들의 연관 관계를 / 추상적으로 표현한 것

### 1. 시나리오(유스케이스) 관점

**최종 사용자가 인식하는 시스템의 기능**

시스템이 → 사용자에게 제공하는 **기능에 주목**하는 관점

기능 하나하나가 유스케이스로 표현되기 때문에 유스케이스 관점

시스템은 여러 다이어그램을 사용해 구성할 수 있는데, / 유스케이스 다이어그램 → 다른 4개 관점에서 사용되는 다이어그램의 근간. → **분석 및 설계 전 과정에서 사용됨**

설계자가 사용자와 대화하는 데도 사용됨.

- **정적 표현**: 유스케이스 다이어그램
- **동적 표현**: 상태 다이어그램, 순차 다이어그램, 통신 다이어그램, 활동 다이어그램

### 2. 논리적(디자인) 관점 (분석가/설계자)

**시스템 내부**를 들여다봄

→ (시스템 기능 제공을 위해 필요한) 클래스나 컴포넌트 및 이들의 관계에 초점

- **정적 표현**: 클래스 다이어그램, 객체 다이어그램
- **동적 표현**: 상태 다이어그램(클래스 내 동작 표현), 순차-통신 다이어그램(클래스 간 상호작용 표현), 활동 다이어그램(클래스 연산 동작 표현)

### 3. 프로세스 관점 (시스템 통합자)

개발자 - 시스템 통합자를 위한 것

실제 구동 환경을 살펴봄으로써 → (논리적 관점과 같이) **시스템 내부의 구조(클래스 간 관계, 클래스의 동작, 클래스 간 상호작용)**에 초점

- But 모든 클래스에 관심있는게 X → 독자적인 제어 스레드를 가질 수 있는 클래스에 초점
- 시스템의 동시성 + 동기화 관심
  → 시스템에 어떤 프로세스와 스레드가 있는지 식별하고 / 그들 간의 관계(소유, 동기화 등) 표현
- UML 다이어그램에서는 프로세스와 스레드를 → 동적 클래스의 스테레오타입으로 나타냄
- 동적 표현: (시간의 흐름에 따른 변화를 표현하는) 상태 다이어그램, 순차 다이어그램, 협동 다이어그램, 활동 다이어그램
- 시스템 구성 표현: 구현을 위해 컴포넌트 다이어그램이나 배치 다이어그램을 사용해 시스템 전체 구성을 표현

### 4. 개발(구현) 관점 (프로그래머)

물리적 시스템에서 사용하는 소프트웨어 서브시스템의 **모듈**(원시 코드, 데이터 파일, 컴포넌트, 실행 파일 등으로 구성)이 어떤 연관관계가 있고 설계와 어떻게 연결 관계를 나타내는지 관심

다음과 같은 다이어그램을 이용해 구현 모듈 간의 의존 관계를 나타냄

- 정적 표현: 컴포넌트 다이어그램
- 동적 표현: 상태 다이어그램, 순차/통신 다이어그램, 활동 다이어그램

### 5. 물리적(배치) 관점 (시스템 엔지니어)

시스템에서 필요한 하드웨어 환경을 포함해 + 시스템을 구성하는 처리 장치 간 물리적인 배치에 초점

다이어그램을 사용해 서브 시스템이 물리적인 환경에서 어떻게 배치, 연결, 실행되는지를 노드 간 관계로 나타냄

시스템의 분산 구조와 실행할 때 컴포넌트 배치 상태를 나타냄

- 정적 표현: 배치 다이어그램
- 동적 표현: 상태 다이어그램, 순차/통신 다이어그램, 활동 다이어그램

## ☑️ 아키텍처 스타일

데이터 중심형 스타일

### 데이터 중심형 스타일 (리포지토리 스타일)

주요 데이터가 리포지토리에서 중앙 관리됨

리포지토리 + 여기에 접근하는 서브 시스템

- 시스템에서 공동으로 활용하는 데이터: 리포지토리에 보관
- 리포지토리(공유 데이터) → (축소해서 보면) DB, Encry..pedia

### 클라이언트-서버 스타일

- **씬 클라이언트 스타일**
- **팻 클라이언트 스타일**
  - 새로운 버전의 애플리케이션이 출시되면 모든 클라이언트에 배포/설치해야 하는 단점

### 계층 스타일

각 계층 응집도 ⬆️, 계층 간 결합도⬇️ → 재사용, 유지보수 용이

계층 간 역할 분담 명확 → 각 계층 쉽게 변경 가능

대부분의 운영체제, 통신 시트템이 계층 스타일을 사용하고 있음

> [!NOTE]
>
> - 약결합이 좋은 시스템 → 수정, 유지보수 쉬움 (모듈 한 부분만 갈아끼면 됨)
> - 강결합 → 수정, 유지보수 어려움
> - 대체적으로 backend에서 돌리는 게 좋음

### MVC (Model/View/Controller) 스타일

기능별, 특성별 모듈화 → 명확하게 분리해서 유지보수 쉽게하고 확장성, 유연성 ⬆️

`모델`, `뷰`, `제어`

### 제어 관계 > 데이터 흐름 스타일

- 파이프 필터(pipe and filer) 구조
  - `필터`: 필터에 해당하는 서브시스템이 / 하나의 데이터를 입력받아 → 처리 → 데이터 스트림 하나 출력 → 결과를 다음 서브시스템으로 넘겨주는 과정 반복
    - 하나의 필터는 여러 포트로 데이터를 보낼 수 있음
  - `파이프`: 필터를 거쳐 생성된 데이터 스트림 하나를 → 다른 필터의 입력에 연결
- 데이터를 변환하는 시스템에서 주로 사용
- 전체 변환 작업은 독립적인 단계로 나뉨
- 파이프+필터 조합해서 만드는 아키텍처에 적합: 이미지 프로세싱 시스템, 컴파일러의 순차적인 변환 처리기, 유닉스의 shell 등
- 사용자 개입 없이 데이터 흐름이 전환되는 경우에 사용
- 필터 또는 파이프 단위로 나누어 개발 가능 → 동시에 개발이 가능

### 아키텍처 스타일의 장점

1. **개발 기간 단축, 고품질 SW 생산**
2. **의사소통 수월:** 아키텍처 익숙한 개발자끼리 공통된 아키텍처 공유
3. **유지보수 용이**: 개발 참여하지 않은 사람이라도 비즈니스 로직 알고 있으면 유지보수 어려움 줄어듦
4. **검증된 아키텍처:** 사용을 통해 이미 검증된 아키텍처 스타일인까 → 안정적 개발
5. **구축 전 시뮬레이션 가능:** 이미 알려진 아키텍처 스타일 사용하면 → 시스템 개발 전 시스템 특성 시뮬레이션 가능
6. **기존 시스템에 대한 빠른 이해:** 어떤 아키텍처 스타일로 기존 시스템이 개발되었는지 알면 → 더 빨리 이해 가능

<br />s

# 02 클래스 간의 관계 (연관화, 집단화, 일반화)

## 1) 연관 관계 association relationship

클래스 간 서로 메시지 주고받으며 사용

### 양방향 연관 관계

### 역할이 부여된 연관 관계

### 다중 연관 관계

### 단방향 연관 관계

### 연관 클래스

점선을 사용해 나타냄

화살표가 없으면 양방향 연관 관계

## 2) 일반화 관계

is a kind of 관계

## 3) 집합 관계

일체형 컴퓨터 X → 본체, 모니터, 키보드 각각 존재하는 컴퓨터의 경우 → 모니터 고장나면 다른 걸로 교체 가능 + 다른 곳에서도 사용할 수 있음

- 모든 객체가 별개의 생명주기를 가지고 있음 + 각각 독립적으로 동작 → **약한 결합 관계**
- 연결은 직선으로, 머리 부분은 속이 비어 있는 마름모
- 집합 관계와 유사한 것 → 합성 관계

## 4) 합성 관계

- 부분 객체는 전체 객체가 없어지면 같이 없어진다
- 모든 객체가 같은 생명주기 → 강한 결합 관계

> [!NOTE]
>
> 노트북 → 모니터 뜯어낼 수 없음.
> 완전히 종속되어 → 독립된 객체로 존재할 수 X
> 비슷하지만 다르다
> 구성한다(composition) 라는 부분은 같음

## 5) 의존 관계

> 연관관계: 상대의 클래스를 사용(참조)할 때 관계. 클래스 A의 변화 → 클래스 B의 변화로 연결됨

의존관계는 상대의 메서드를 가지고 있음(매우 짧은 시간 관계유지)

- 다른 클래스 객체를 **인자**로 받아 메서드 사용
- A 클래스 메서드 내부에서 B 클래스 객체를 생성해서 메서드 사용 (**지역 변수**로 사용)

## 6) 실체화 관계

- 일반화 관계: 공통 특성을 갖는 클래스를 묶어서 → 새로운 이름 클래스 만들어서 → 상속 구조
- 인터페이스 클래스: 메서드의 공통 특성 묶어서 → 새로운 인터페이스 만들고 → 공통의 이름을 붙임
  - 변수를 정의할 수 X
  - 추상 메서드를 가짐 → 구체적인 실현은 하위 클래스에서 구현 == 이와 같은 관계를 `실체화` (realization)라고 함
  - (모양은 상속 구조처럼 생겼지만) 상속 관계를 맺을 수 **없음**
  - 스테레오타입으로 <<interface>> 사용
  - 하위 클래스와의 연관 → 점선으로 표현
    화살표 머리부분은 하위 클래스 → 상위 클래스로 향함
    모양은 속이 빈 삼각형

<br />

# 03 클래스 설계 원칙 (5)

## 1) 단일 책임 원칙 SRP;Single-Responsibility Principle

**✨ (클래스를 설계할 때) 클래스를 변경해야 하는 이유는 단 하나여야 한다.**

응집도 높은 설계

객체 수가 늘어나고 구조가 복잡해지더라도 재사용, 유지보수 위해 지켜져야 함

기능에 대한 부분이 하나

> [!NOTE]
>
> 기능적 모듈 설계
>
> SOLID
>
> 수강 신청 하나가 모듈이니까 모듈은 아님 → 추상화해서 하나의 모듈로 생각을 해보자 라고 가정하는것
>
> - 순차적 결합도: 단계별 입출력
> - 시간적 결합도: 단계별 입출력이 아닌 시간의 흐름에 따라 진행

## 2) 개방 폐쇄 원칙 OCP;Open-Closed Principle

✨ **변경에는 닫혀 있어야 하고, 확장에는 열려 있어야 한다.**

어떤 것은 개방, 어떤 것은 폐쇄

1. 계속 바뀌는 것 → 상속 구조로 만듦

2. Video-Player 클래스에서 이들을 호출해 사용하도록 설계

**장점**

- 변경에 닫혀 있는 설계
  - 새로운 지원 파일 형식 추가되어도 Video-Player 클래스를 수정할 필요 X
  - 계속된 추가사항 있어도 그들끼리만 추가할 수 있도록 설계
  - (새로운 지원 파일 형식 추가) 변경에 영향을 안받도록 닫혀 있게
- 확장에 열려 있는 설계
  - 새로운 클래스 쉽게 추가할 수 있는 구조로 설계

## 3) 리스코프 교체 원칙 LSP; Liskov Substitution Principle

✨ 상위 클래스의 객체는 / 언제나 자신의 하위 클래스의 객체로 / 교체할 수 있어야 한다.

상위 클래스 객체가 들어갈 자리에 → 하위 클래스 객체 넣어도 문제 없이 잘 작동

## 4) 의존 관계 역전 원칙 DIP; Dependency Inversion Principle

✨ 클라이언트는 구체 클래스가 아닌, 추상 클래스(인터페이스)에 의존해야 한다.

의존도⬆️, 결합도⬆️ 응집도⬇️ → 최악의 클래스 설계

## 5) 인터페이스 분리 원칙 ISP; Interface Segregation Principle

✨ 클라이언트는 자신이 사용하지 않는 메서드와 의존 관계를 맺으면 안된다.
