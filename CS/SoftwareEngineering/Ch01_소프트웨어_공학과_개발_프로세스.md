# 1. 소프트웨어의 이해

## 소프트웨어의 정의

- `프로그램`: 프로그래밍한 원시 코드(source code)
- `소프트웨어`: 프로그램(코드)을 비롯해 개발 과정에서 생성되는 모든 산출물(자료 구조, 데이터베이스 구조, 테스트 결과 등) + 각 단계에서 만들어지는 문서와 사용자 메뉴얼 등을 **모두 포함**

> [!NOTE]
>
> 💡 전체 관리 == 형상관리
>
> - 산출물 **포함해서** 만들어지는 게 소프트웨어다.
> - 코드 자체는 소프트웨어에서 일부분이다.

## 소프트웨어의 특징

- 제조(감가상각 발생)가 아닌 **개발**
- 소모가 아닌 **품질 저하**
  - 하드웨어 부품도 오래 사용하면 먼지, 열 등으로 성능이 저하될 수 있다.
  - 소프트웨어 특징은 하드웨어와 **달리** 닳지 않는다.
  - 이상적 상황에서만 사용 기간 내내 문제 없이 사용 가능 → 실제는 변경 사항, 환경 변화, 사용자 요구 계속 발생, 운영체제 등 설치 환경 변화에 따라 실패율 급격히 증가 가능

> [!NOTE]
>
> 유지보수 4가지 방법: ECAP (Enhancement, Corrective, Adaptive, Preventive)

## 소프트웨어 공학

- 공학
  - 과학적 지식을 활용해 문제를 해결하는 데 한정된 기간과 비용의 제약을 받음
  - 공학이 발전하면 → 문제 해결을 위한 기술 축적 + 공학적 원리가 개발
    → 실무에 적용해 문제 해결의 절차를 만들고, 반복적인 절차를 개선해 표준을 만들어냄
- 소프트웨어(= 소프트웨어 개발) 공학
  - “품질 좋은 소프트웨어를 경제적으로 개발하기 위해 계획을 세우고, 개발하며, 유지보수하는 전 과정에서 공학, 과학 및 수학적 원리와 방법을 적용해 필요한 이론과 기술들에 관해 연구하는 학문”
  - “**소프트웨어를 개발하는 과정**에 공학적인 원리를 적용해보자”
  - because 소프트웨어 개발의 어려움(과정의 복잡함, 참여 인력이 많음, 개발 기간이 긺)을 해결 + 생산성 향상 + 사용자가 만족하는 고품질 소프트웨어 제품을 만들기 위함
  - 소프트웨어 개발 과정
    - “한 소프트웨어를 만들기 위해 계획 단계에서 ~ 유지보수 단계에 이르기까지 일어나는 일”
    - = 계획 → 요구사항 → 분석 → 설계 → 구현 → 테스트 → 유지보수
    - 소프트웨어 개발 생명주기 Software Development Life Cycle(SDLC)

> [!NOTE]
>
> - 품질에 대한 부분 → Product, Process로 나눔
> - 9126의 품질요소
> - CLMI의 Process 절차
> - 개발자가 요구사항에 임의로 추가하거나 수정하면 안됨. 요구사항에 요구한 대로만 해야함.

<br />

# 2. 소프트웨어 개발 프로세스

- 프로세스: 일을 처리하는 과정 or 순서
  - “주어진 일을 해결하기 위한 목적으로 그 순서가 정해져 수행되는 일련의 절차”

## 소프트웨어 개발 프로세스

- 소프트웨어 개발 프로세스 == **\*작업 순서의 집합**
  - \*소프트웨어 개발 시 일을 수행하는 작은 단위 = 작업(task)
- not only 작업 순서 but also 일정, 예산, 지원과 같은 **제약 조건(constraint)을 포함하는 일련의 활동**(activity)
- **좁은 의미**의 소프트웨어 개발 프로세스
  - 소프트웨어 제품 개발 시 → 필요한 절차나 과정으로 → 사용자의 요구사항을 소프트웨어 시스템으로 구현하기 위한 → 일련의 활동
- **넓은 의미**의 소프트웨어 개발 프로세스
  - not only 절차, 과정 but also 작업 수행하는데 필요한 방법과 도구 + (개발과 관련된 실제 절차를 따라) 작업을 수행하는 참여자들까지 포함
  - == 소프트웨어 개발 목적을 이루는 데 필요한 통합적 수단
- 많은 반복, 시행착오 통해 얻은 절차나 방법에 관한 지식을 → 같은 작업을 수행하는 다른 사람에게 전달해서 / 시행착오를 줄이고 빠르게 적응해 일을 할 수 있도록 가이드 역할을 함

> [!NOTE]
>
> - 개발 프로세스 세 가지 구성요소 → 사람(인력, 가장 중요), 방법론, 도구
> - 상호 유기적으로 결합이 되어야만 제대로 된 소프트웨어를 만들 수 있다.

## 소프트웨어 개발 프로세스 모델

- **대규모 소프트웨어에 적용**
  - 규모가 작은 소프트웨어는 개발할 때 굳이 분석, 설계.. 단계 거치지 않고 바로 코딩, 필요한 때마다 수정
  - BUT 운영체제나 데이터베이스 관리 시스템처럼 대규모 소프트웨어는 개발 전 여러 소프트웨어 개발 프로세스 모델 중에서 가장 적합한 것을 프로젝트 표준으로 정하고, 모든 참여자가 표준 절차에 따라 개발해야 함
- **정의:** 소프트웨어 개발 프로세스 모델 = 소프트웨어를 어떻게 개발할 것인가에 대한 **전체 흐름을 체계화**한 개념
  - 개발 계획 수립부터 ~ 최종 폐기까지 **전 과정 관리**
- **목적:** 고품질 소프트웨어 제품을 만들기 위함
- **역할**: 프로젝트에 대한 전체적인 기본 골격을 세워줌
  - 일정 계획 수립 + 개발 비용 산정 + 여러 자원 산정, 분배
  - 참여자 간 의사소통 기준 정함 + 용어의 표준화 + 개발 진행 상황 파악
  - 각 단계별로 생성되는 문서를 포함한 산출물을 활용해 검토할 수 있게 해줌

<br />
<hr />
<br />

# 소프트웨어 개발 프로세스 모델

# 1. 주먹구구식 모델 build-and-fix

정확한 앞뒤 계산 X 일을 대충 처리할 때

- 공식적인 가이드라인 X 프로세스X 요구분석명세서X 설계서X
- 간단한 기능만 정리해서 개발하는 개발방식
- 일단 코드 작성해서 제품 만든 후 → 요구분석, 설계, 유지보수 생각

<br />

# 2. 선형 순차적 모델 (폭포수 모델) linear sequential - V모델

- 고전적 생명 주기(classic life cycle)
- 초기에 개발된 전통적인 모델 → 공장 생산 라인 작업 프로세스와 유사.
- 표준 프로세스를 정해 → 소웨 순차적 개발

## ☑️ 개발 절차

계획 (개발 계획서) → 요구분석 (요구분석명세서) → 분석 → 설계 (설계서) → 구현 (모듈별 코드) → 테스트 → 유지보수

- 각 단계가 하향식으로 진행 (top-down)
- 병행되거나 거슬러 반복되지 X
- 각 단계 확실히 끝내고 결과 확인 후 다음 단계

## ☑️ 장단점

- **문서 중심 모델** → 각 단계마다 요구분석명세서, 설계서, 코드 문서, 데이터베이스 매뉴얼, 사용자 매뉴얼, 운영 매뉴얼 등 상세한 문서 생성
- **각 단계 명확히 구분**
  → 각 단계 산출물이 다음 단계 입력 자료로 사용됨
  → 해당 단계 오류 수정하지 않고 다음 단계 넘어가면 오류 끝까지 남을 수 있어 초기 단계에서 오류 해결하는게 중요

### 장점

- 관리 용이
  - 절차가 간결, 이해하기 쉬움
  - 순차적 모델 → 단계별 진척 사항 관리 용이
- 체계적 문서화
- 요구사항 변화가 적은 프로젝트에 적합
  - 초기에 어느 정도 요구사항이 확정되어 → 변화가 적은 프로젝트 개발 시 적합

### 단점

- 각 단계는 앞 단계가 완료되어야 수행 가능
- 각 단계마다 작성된 결과물이 완벽한 수준으로 작성되어야 → 다음 단계 오류 넘겨주지 않음
- 사용자가 중간에 가시적 결과 볼 수 없어 답답해함

## ☑️  V 모델

폭포수 모델의 변형

- 테스트 단계 추가 확장
- 각 개발 단계 검증에 초점

> [!NOTE]
>
> - V모델은 여러가지 형태에 대한 모델
> - 요구분석 → 설계(개략설계(=아키텍쳐 설계), 상세설계(=모듈 설계)) → 구현 → 테스트 → 사용자에게 주기 전 내 식대로 테스트(=인수 테스트)
> - 요구분석은 시스템 테스트와 연관된다. 아키텍쳐는 통합 테스트와 연관, 모듈 설계는 단위 테스트와 연관

# 3. 진화적 프로세스 모델 evolutionary process (프로토타입 모델) - 프로토타입 모델, 나선형 모델

폭포수 모델 대응 한계 → 새로운 요구 대응 위한 방법

진화적 프로세스 모델 대표적 방법: `프로토타입 모델`

(프로토타입 모델 결과)프로토타입에 + 위험 분석 단계 추가 → `나선형 모델` (얘도 진화적 프로세스 모델의 변형임)

1. 초기 사용자 요구 따라 → 가상으로 실행되는 초기 버전 프로토타입 제작
2. 사용자 → 사용자 인터페이스 중심 화면 + 실행 후 나타나는 가상 결과 봄
3. 변경된 요구사항 반영/추가 → 2차 프로토타입 제작

## ☑️ 프로토타입 모델

프로토타입: 대량 생산에 앞서 미리 제작해보는 원형, 시제품

정식 절차에 따라 완전한 소웨 만들기 **전에** 사용자 요구대로 모형 만들고 사용자와 의사소통하는 도구로 활용

- 모델하우스 예시
- `프로토타이핑`: 프로토타입을 만드는 것
- **폭포수 모델 기반으로 개발** + 사용자 요구 충분히 반영 위해 프로토타입을 추가한 모델
- 사용자 요구 불투명, 요구사항 변화가 계속 많이 발생하는 경우 적합

### 개발 절차

1. 요구사항 정의, 분석
   - 완벽하게X 개략적인 요구사항 정의
2. 프로토타입 설계
   - 완전한 설계를 하는게 X 사용자와 대화할 수 있는 수준으로 설계
   - 최종 코딩 할 수 있는 설계 X 사용자 인터페이스 중심 설계
3. 프로토타입 개발
   - 완제품 X 실제로 수행되는게 X
4. 사용자에 의한 프로토타입 평가
   - 사용자 추가 수정 요구사항 전달 → 개발자 이를 반영해 2차 설계 → 2차 프로토타입 개발 → … → 사용자 추가 요구사항 없을 때 최종 프로토타입

### 장단점

✨

- 구체적이고 원활한 대화
- 요구사항 한 번에 정의X 여러 번 반복 과정 → 사용자의 요구가 충분히 반영된 요구분석 명세서
- 사용자 예상치 못한 새로운 요구사항 발견 가능, 소웨 모습 예측 가능, 개발 초기 만족감
- 사용자 요구가 충분히 반영되어 최종 제품 → 유지보수에 필요한 노력, 시간 줄일 수 있음

💩

- 투입 인력, 비용 산정 어려움
- 빠르게 나올 것이라고 사용자가 착각
- 프로토타이핑 과정 관리, 통제 어려움
- 중간 점검을 할 수 있는 이정표나 산출물 생성 어려움
- 개발 범위 명확하지 않음 → 소프트웨어 개발 목표나 종료 시점 불명확, 프로토타입 추가 비용 들 수 있음

## ☑️ 나선형 spiral 모델

> [!NOTE]
>
> - 진화적 프로세스 모델
>   - 1차 프로토타입 → 사용자 만족 → 바로 최종 제출
>   - 아니면 계속해서 수정 반복
> - 프로토타입 모델
>   - SDLC 소웨 개발 수명 주기
>   - 프로토타입 == 원형 또는 시제품
>   - 사용자 요구가 불투명하고 요구사항 변화가 많이 발생하는 경우에 적합함
>   - 개발 초기에 만족도가 높다 (요구사항 만들어지는 순간 바로 시제품 갖다줌 → 사용자가 다 만들었다고 오해함)
>   - 범위가 불분명하다는 단점
>   - 개발 절차: 항상 프로토타입을 만들면 사용자에게 질문 → 됐어? 수용해야 다음 단계로 넘어감
> - 나선형 모델 (Spider Model)
>   - 초기 요구분석 후 → 프로토타입 개발 이전 **위험 분석 단계** 거침
>   - 위험분석 (인력 퇴사 등) → 모델에서 위험분석 하는 모델은 얘밖에 없음
>   - 계획 및 요구 분석 → 위험 분석 → 프로토타입 개발 → 사용자 평가 4단계 꼭 알아야 함
>   - 보엠이 만들었다
>   - 장점: 프로토타입의 가장 장점은 사용자의 요구를 바로바로 수용할 수 있다는 점
>   - 단점: 빙글빙글 도니까 기간이 길어질 수 있고 → 제한된 자원 처리 어려움
>   - 범위가 일정치 않아서 관리가 어려움 (폭포수 모델은 범위 한정이 가능한 장점)

### 개발 절차

**1. 계획 및 요구분석 planning and requirement analysis 단계**

- 사용자 개발 의도 파악, 프로젝트 목표 명확히
- 여러 제약조건 대안 고려한 계획 수립
- 사용자 요구 통해 파악한 기능 요구사항, 성능같은 비기능 요구사항 정의, 분석

**2. 위험 분석 단계**

- 프로젝트 수행에 방해되는 위험 요소 찾아 → 목록 작성, 예방 대책 논의
- 위험 요소 평가 → 개발 영향 얼마나 주는지, 대안 없는지 분석

**3. 개발 단계 (프로토타입 개발)**

다른 소웨 개발 프로세스의 설계,구현에 해당

**4. 사용자 평가 단계**

### 장단점

- 개발 후반에 가서 갑작스러운 위험으로 인해 프젝이 중단되는 심각한 사태 일어날 확률 비교적 적음 + 사용자 요구 충분히 반영
- 요구분석 → 위험분석 → 개발 → 사용자 평가 반복적으로 계속 진행 → 프젝 기간 길어짐, 프젝 관리 어려움
  → 위험 관리 중요한 만큼 위험 관리 전문가가 필요하다는 부담

<br />

# 4. 단계적 개발 모델 - 점증적/반복적 개발 방법

> [!NOTE]
> 점증적 개발과 반복적 개발 방법으로 나뉨 - 점증적 방법: 기존 시스템을 알아야 함 그래야 융합이 가능하기 때문에

## ☑️ 점증적 개발 방법: 개발 범위 증가 (incremental)

- 하나가 끝나면 그다음, 하나가 끝나면 그다음~
- 중요하다고 생각되는 부분 차례로 개발 → 일부 사용하면서 개발 범위를 점차 늘려가는 방식
  - Ex. 도서 집필, 3층 건물 건축, 대학 종합정보시스템 개발
- 요구분석명세서에 있는 시스템 전체를 기능에 따라 **독립성 높은 서브 시스템으로 분할**, 각 서브시스템을 단계적으로 하나씩 릴리즈해 완성

### 장점

- 한꺼번에 많은 비용 들이지 않아도 됨
- 완전히 새로운 시스템 전체를 한 번에 주었을 때 → 조직이 받는 충격 완화
- 소웨 단계적 도입 → 조직에 자연스럽게 변화를 줄 수 있음
- 개발 측면에서 이미 사용하고 있는 서브시스템이 있음 → 어떤 유형으로 개발해야 하는지 잘 알 수 있음 → 사용자에게 원하는 결과

### 단점

- 서브시스템 서로 관련 있을 경우 처음 설계할 때부터 ~ 이후 개발할 다른 서브시스템 연관성 고려해야 함
- 통합하는 데 어려움

## ☑️ 반복적 개발 방법: 품질의 증가 (iterative)

초기에 시스템 **전체** 일차적으로 개발 → 인도

→ 각 서브시스템 기능, 성능 변경/보강 완성도 높임

→ 업그레이드된 릴리즈 버전 인도

- 초기 요구사항 불분명한 경우 적합
- 실제 개발에서는 점증적 + 반복적 개발 방법 함께 사용

<br />

# 5. 통합 프로세스 모델 (RUP - 도구구전)

폭포수 모델 문제점 해결 위해 → 작업을 계속해서 반복 수행하는 `반복적 개발 방법론`

반복적 개발 방법론 사용 → **`통합 프로세스 모델 (Unified Process, UP)`**

- OMG(Object Management Group)가 공개한 UML(Unified Modeling Language)과 함께 제안되어 통합된 프로세스
- 이후 Rational사에 의해 **`RUP(Rational Unified Process)`**라는 이름으로 상품화 (Rational → IBM에 통합)

## ☑️ 통합 프로세스 모델 절차

**도입 → 구체화 → 구축 → 전이** 4단계

각 단계도 여러 개의 작은 단위(반복;iteration)로 나뉘어 → 각 반복 구간을 하나씩 정복해감

반복 주기를 시작하기 **전** / 기준선(베이스라인) 계획을 세움 → 반복 주기 끝나면 / 실행 가능한 산출물 도출 → 얘를 위험 요소 제거 여부 판단하는데 사용

<br />

# 6. 애자일 프로세스 모델 - 스크럼, CBD

## ☑️ 스크럼 방식

### 1️⃣ `제품 기능 목록` 작성

**우선순위가 매겨진 사용자 요구사항 목록**

- 우선순위 → 고객 측 대표 **제품 책임자**가 결정
- `사용자 스토리`: 제품 기능 도출 후 → 각 기능 간략히(상세히X) 서술하는 것
  - 개발 관련 구체적X 사용자가 이해할 수 있는 ( → 사용자에게 필요한 이야기이므로 개발자에게 필요한 내용을 서술해서는 안된다)
  - 구성 → 카드(포스트잇), 대화, 확인
  - 개발자들이 보면 개발규모, 투입 공수 짐작 가능해야 함
  - 요구사항 많으면 추정 어려우니까 → 개발 규모 작게 하는게 바람직
  - `스토리 포인트`**(SP)**: 요구사항 규모를 측정하는 단위 → 업무량 이용해 산정
    - 스토리 간 상대적 업무량 비교 → 가장 적을 때 1, 이 기준으로 얼마나 큰지에 따라 스토리 포인트 산정
    - 일/주/월 시간 단위 X → 추상 개념 예측 (난이도, 소요시간, 복잡도 고려 1시간을 1포인트로 정해 산정)
    - 스토리 포인트 산정 → 개발자가 주도적인 역할
      우선순위 중요도 판단 → 업무 분석가가 함
  - 제품 기능 목록에 있는 업무 목록은 프로젝트를 수행하는 동안 수정되고 정제된다.
  - 업무의 우선 순위를 결정한 후 변경 가능

### 2️⃣ 스프린트 계획 수립, 회의

스프린트 → 작은 단위 개발 업무를 / 단기간 내 수행

- 요구사항 안정적, 시니어 개발팀 → 1~2주
  요구사항 변화 많음, 주니어 개발팀 → 4주
- 외부 개발 방해 요소를 차단하는 것이 `스크럼 마스터`의 역할
- 하나의 스프린트는 개발 **완료 여부와** **관계 없이** 정해진 일정이 지나면 끝남

**스프린트 계획 세우기 위한 계획 회의**

1. 전체적인 스프린트 계획 회의: 스크럼 마스터 중심 제품기능목록 검토
2. 세부적인 스프린트 계획 회의: 우선순위 높은 항목 어케 구현할건지 작업계획

**스프린트 구현 목록(sprint backlog) 작성**

제품 기능 목록에 있는 스토리 중 선택해 작성

스프린트 계획 회의에서 결정

목록 하나하나 개발이 완성되면 → 스프린트 주기가 완성됨

### 3️⃣ 스프린트 수행

**`소멸 차트(burndown chart)`**: 계획 대비 작업이 어떻게 진행되고 있는지 → 날짜별 남은 작업 (burnup 차트와 혼용해서 사용 가능)

**일일 스크럼 회의**

**스프린트 현황한 (task board)**

**스프린트 진척 관리**

### 4️⃣ 스프린트 개발 완료

최종 제품 → 모든 스프린트 주기가 끝나면 완성

### 5️⃣ 스프린트 완료 후 회고, 검토 회의 , 두 번째 계획 회의

- **스프린트 검토 회의**
  - 전체 흐름 확인, 비즈니스 가치 점검에 중점
- **스프린트 회고**
  - 단점보다, 강점을 찾아 더 극대화에 주안점
  - 문제점 해결방안을 찾는게 ㄴㄴ 문제점 확인, 기록하는 정도로만
  - **프로세스 품질은 측정하지 X**
- **배포 목록(release backlog) 작성**
  - 사용자에게 전달되는 배포본의 기능 내역, 시기, 스프린트 주기, 배포 일정 결정

## ☑️ 스크럼 개발 관련자 역할

## ☑️ 스크럼 방식의 장단점

단점: 투입 공수를 측정하지 않음 → 효율적으로 수행됐는지 알기 어려움

스크럼은 프젝 관리에 무게 중심을 많이 둔 방법 → 프로세스 품질을 평가하지 않아서 품질 관련 활동이 미약함 → **품질의 정도를 알 수 없음**
