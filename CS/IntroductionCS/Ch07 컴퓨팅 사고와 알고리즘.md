# 01 컴퓨팅 사고의 이해

## 컴퓨팅 사고의 개념

- **일상생활에서 문제 해결**
  → 인간이 만든 알고리즘을 / 컴퓨터에서 계산해 / 그 결과를 보여주는 것 - Ex. 네비게이션의 최단 거리 검색, 스마트 TV의 영화 추천

- **컴퓨팅 사고 (Computational Thinking, CT)**

  - **컴퓨터를 이용하여 / 문제를 해결하기 위한 / 논리적이고 창의적인 생각 방식**

  - 컴퓨터가 효과적으로 수행할 수 있도록 문제를 정의하고 / 그에 대한 답을 기술하는 것이 포함된 / 사고 과정 일체를 일컫는다.

  - 정답이 하나가 아니라 여러 가지일 수 있는 문제(Open-ended Problem)는 / 다양한 변수에 기반한 / 포괄적이며 유의미한 해답 도출이 필요한데,
    → 컴퓨팅 사고를 통해 발견한 아래 알고리즘이 필요 - 문제 분해 (decomposition) - 자료 표현 (data representation) - 일반화 (generalization) - 모형 (modeling)

  - 컴퓨팅 사고 == 문제해결 과정. 다음 특징을 포함하고 있다.
    1. 자료를 분석하고 논리적으로 조직화
    2. 데이터 모형화, 자료 추상화, 모의시험
    3. 컴퓨터 도움을 받을 수 있도록 문제를 구성
    4. 가능한 해결책을 식별, 테스트하고 구현
    5. 알고리즘적 사고를 통해 해결책 자동화
    6. 본 과정을 다른 문제에 대해 일반화하고 적용

## 컴퓨팅 사고의 사례

- **2진수와 식당 비유**: 메뉴가 작을수록 회전율이 빠름

  - 10진수의 사칙연산을 회로로 구성하는 건 매우 어려움
  - 2진수로 사칙연산 한 후 → 결과만 10진수로 보여주는 계산기를 만든다면 → 회로를 구성하는 건 간단함

- **입출력 채널과 푸드코트 비유**: 줄을 설 때 조리 속도가 다른 한식, 분식 분리하면 효율적임

  - 입출력 장치를 느린 채널과 빠른 채널로 분리해 사용하면 / 전체 입출력 효율이 올라감

- **버퍼와 공장 비유**: 사과를 잘게 부수는 건 매우 빠르므로 기계에 하나씩 사과를 옮겨 넣는 건 비효율적 → 기계속도를 맞추려면 사과를 큰 바구니에 담아 통째로 옮겨야 함

  - 버퍼(큰 바구니): 속도 차이가 많이 나는 두 장치 사이에 끼어서 / 속도 차이를 완화해주는 장치

- **캐시와 조미료 통 비유:** 조미료를 대용량 포장에서 덜어쓰는 건 불편하므로 → 조금씩 덜어 놓은 조미료 통 사용

  - 캐시: 앞으로 사용이 예상되는 것을 미리 가져다 놓은(prefetch) 것

- 병렬 처리와 주방 비유: 주방장 더 채용 + 요리할 수 있는 주방 하나 더 만들면 빠르게 처리됨
  - 병렬처리: 작업 2개를 동시에 처리하는 기법

<br />

# 02 컴퓨팅 사고의 구성

## 컴퓨팅 사고의 4가지 구성

### 1. 추상화

문제에서 불필요한 세부사항을 제거하고 / **중요한 특징만으로 문제를 구성함**으로써 / 문제 해결을 더 쉽게 하는 과정 (문제 본질을 쉽게 파악할 수 있게 하는 작업)

- 추상화 예시:

  - 구글 맵(모든 길이 다 표시) → **지하철 노선도**(지하철 이동 시 지하철 정보만 있는 지하철 노선도가 구글맵보다 편리)
  - 픽토그램 → 음식 추상화 등 멀리 떨어진 곳에서도 뭘 팔고있는 가게인지 쉽게 인지

- **`일반화`:** 추상화로 공통의 특성(특징)을 추려서 만든 개념
  - Ex. 수열의 일반화

### 2. 분해

추상화한 문제를 → (해결하기 쉬운) 작은 단위의 문제로 나누는 과정

(복잡한 문제를 → 풀기 쉬운 간단한 문제로 나누는 것)

- **`분해 정복 (Divide and Conquer)`**: 문제를 작은 문제로 분해해 이를 해결하고, / 해결된 작은 문제를 결합해 / 큰 문제를 해결하는 방식
  - Ex. 이진 탐색 binary search
- Ex. 타일 붙이기 문제

### 3. 패턴 인식

추상화/분해를 한 후 → 데이터를 특징별로 나누어 / 유사한 문제 해결 방식이 있는지 찾아보는 과정

(**문제 혹은 데이터에 / 적용 가능한 의미 있는 패턴을 찾아내는 과정**)

- 패턴을 찾을 수 있다면 문제를 해결하기 쉬움
- Ex.
  - 걷는 사람의 일정한 패턴: 오른발 앞 왼팔 뒤, 왼발 앞 오른팔 뒤
  - RGB 패턴: 조합에 따라 만들 수 있는 색상, 채도, 명도를 만들 수 있음
  - 수학의 패턴: 특정 수의 패턴을 찾는다면 문제를 해결하기 쉬워짐
  - 특정 날에만 사람이 몰리는 식당의 테이블 부족 문제

### 4. 알고리즘

어떠한 문제를 해결하기 위해 정해진 일련의 절차나 방법을 공식화한 형태로 표현한 것

(주어진 문제를 어떻게 해결할지 그 **방법과 절차**를 기술한 것)

- Ex. 요리 절차를 적어놓은 레시피

<br />

# 03 알고리즘의 이해

## **☑️ 알고리즘의 표현 방법 (4 - 자연어 / 순서도 / 의사코드 / 프로그래밍 언어)**

### **자연어** (natural language)

- 사람이 일상생활에서 사용하는 언어
- 컴퓨터가 사용하는 프로그래밍 언어와 구별됨
- **자연어로 알고리즘을 표현하는 것은 매우 복잡**

### **순서도** (flow chart)

- 자연어로 파악하기 어려운 / **전체 구조 흐름을 파악하는 데 많이 사용**
- 약속된 기호, 선을 사용해 문제 해결 과정을 표현
- 장점: 알고리즘 흐름을 빠르게 파악 가능
- 단점: 복잡한 프로그램의 순서도 작성이 까다로움

### **의사코드** (pseudo code)

- 특정 프로그램에 사용하는 언어와 **유사한 서술로 알고리즘을 표현한 것**
- 특정 프로그래밍 언어 문법을 따르지 않기 때문에 / 가짜 코드라는 의미로 의사 코드라고 함
- 의사 코드를 작성하면 특정 프로그래밍 언어로 쉽게 변환 가능

## **☑️ 알고리즘의 조건**

- **`입력`**: 알고리즘에 **입력되는 자료가 0개 이상 존재**
  - `*`: 문자 또는 숫자가 0개 이상 나타남을 의미. ex) a\*는 0개 이상의 문자와 일치
- **`출력`**: 알고리즘의 실행되면 → **결과 값이 1개 이상 나옴**
- **`유한성`**: 알고리즘은 **종료되어야 함**
- **`명확성`**: 알고리즘의 **명령이 모호하지 않고 명확해야 함**
- **`효율성(수행 가능성)`**: 알고리즘의 명령은 **수행 가능해야 함**

## ☑️ 알고리즘 설계

: 문제를 해결하기 위해 가장 효율적인 방법을 찾아내는 과정

- 알고리즘을 설계할 때 → 문제의 현재 상태, 목표 상태를 명확히 정의해야 함
- 현재 상태, 목표 상태를 정확히 인지해야 → 현재 상태에서 목표 상태로 도달하려면 / 어떤 작업을 수행해야 하는지 / 그 종류, 순서 파악할 수 있음

### 좋은 알고리즘의 분석 기준

- **`정확성`**: (적당한 입력에 대해) 유한 시간 내에 올바른 답을 산출하는가
- **`작업량`**: (전체 알고리즘에서 수행되는) 가장 중요한 연산들만으로 작업량 측정 (적을수록 좋음)
- **`기억 장소 사용량`**: 필요한 저장 공간 (적을수록 좋음)
- **`최적성`**: 더 적은 연산을 수행하는 알고리즘은 없는가? → “잘 알려진”이 아닌, “가장 좋은”
- **`복잡도`**: 시간 복잡도, 공간 복잡도(메모리 양) → 시간 복잡도, 공간 복잡도 적어야함

### 제어 구조

- **`순차 구조`**: 어떤 일을 처리하는데 필요한 과정을 / **시간적인 순서에 따라 순차적으로** 나타낸 구조
  - 보통 위에서 아래로 하나씩 실행
- **`선택 구조`**: **특정 조건을 만족하는지 아닌지(True/False)에 따라** / 다음 명령을 선택적으로 실행하는 구조
- **`반복 구조`**: 어떤 문제를 해결하기 위해 / **동일한 동작을 반복적으로 실행**하는 구조

## ☑️ 알고리즘 분석

### 알고리즘의 선택 기준

- 결과가 나올 때까지 **실행 시간이 짧은 것**
- 컴퓨팅 기기의 **기억 장소를 적게 사용하는 것**

### 알고리즘의 성능

알고리즘의 실행 단계가 복잡하거나 처리해야 하는 자료가 많을 경우 / 알고리즘의 효율성은 프로그램 성능에 중요한 역할을 한다.

- 알고리즘의 **성능 분석 방법**

  - 알고리즘을 구현한 프로그램을 직접 실행하는 방법
  - 알고리즘의 실행 횟수 등 복잡도를 분석하는 방법

- 알고리즘의 **복잡도**
  - 알고리즘이 특정 기준에 따라 얼마나 빠르게/느리게 실행되는지 나타내는 것
  - 시간 복잡도와 공간 복잡도를 분석하면 → 가장 효율적인 알고리즘을 선택할 수 있음
    - `시간 복잡도`: 알고리즘이 실행되어 ~ 종료될 때까지 **어느 정도 시간이 필요한지 측정하는 방법**
      - 실제 컴터의 실행 시간 측정하기 어렵기 때문에 → 알고리즘의 실행문이 몇 번 실행되는지 횟수를 표시해 측정
      - Big O 표기법: 입력한 값의 크기에 따라 알고리즘 처리 횟수가 얼마나 증가하는지 나타냄
      - ex. 1부터 10까지 수를 더하는 알고리즘
    - `공간 복잡도`: 알고리즘이 문제를 해결하는데 **어느 정도의** **저장 공간을 필요로 하는지** 측정하는 방법
      - **기억 장치 내의 공간을 얼마나 적게 사용하는지가 중요**
      - 저장 공간은 = 알고리즘이 사용하는 공간과 + 입력되어 처리되는 자료 공간을 모두 포함
      - ex. 1부터 10까지 수를 더하는 알고리즘에서 수를 저장하는 방법

<br />

# 04 알고리즘을 이용한 문제 해결

## 알고리즘 설계 실습: 스무고개 문제

```c
if(참가자 숫자 = 출제자 숫자): 종료
else if (참가자 숫자 > 출제자 숫자): '크다' 출력
else: '작다' 출력
```

이진 탐색과 비슷함 → 중간값을 계속 부르는게 정답에 빠르게 접근할 수 있다

## 알고리즘을 이용한 문제 해결 과정

알고리즘을 배우는 것은 → 문제를 푸는 논리적인 과정을 배우는 것

1. **코드 작성**: 의사 코드 형태의 알고리즘 설계
2. **코드 검토**: 의사 코드를 머릿속에서 시뮬레이션
3. **입력/실행**: 프로그래밍 언어로 프로그램 작성 후 실행

- 오류 발생하면 1단계로 돌아가 코드 수정(디버깅), 1~3단계 반복

### 오류

- **`문법 오류 (syntax error)`**
  - 여러 가지 오류 중 가장 간단함 → **어떤 지점에서 오류가 발생했는지 알려주기 때문**
- **`논리 오류 (Logical error)`**
  - 알고리즘을 잘못 만들었기 때문에 발생
  - 문법적 오류가 없는데도 원하는 답이 나오지 않은 오류, 가장 고치기 어려움

<br />

# 05 프로그래밍 언어

컴퓨터에 작업을 지시하는 데 사용하는 언어

ex. 기계어, 어셈블리어, C, C++, 자바, 파이썬

## ☑️ 저급 언어와 고급 언어

### 저급 언어(low level language)

사람이 이해하기 힘든 언어

- 기계어(machine language): 컴퓨터가 이해하는 언어로, 0과 1의 숫자로만 구성
  - 처리 속도 빠름
- 어셈블리어(assembly language): 기계어를 사람이 이해할 수 있는 문자 형태로 바꿔놓은 것

### 고급 언어 (high level language)

사람이 사용하는 단어로 이해하기 쉽게 만든 언어

기계어와 어셈블리어를 제외한 대부분의 언어가 고급 언어

C언어, JAVA, 파이썬 등

## ☑️ 객체 지향 언어 Object Oriented Language

변수와 + 함수를 하나로 묶어 = 객체로 처리하면 → 분리해서 사용할 때보다 편리하게 데이터를 처리할 수 있음

다른 객체 상속이나 데이터 사용할 수 있는/없는 추가 기능도 존재

### **객체 지향 언어 JAVA**

- 객체 지향 언어 중 현재 가장 많이 사용하는 언어
- 호환성 문제를 해결한 언어
- 자바로 프로그래밍하면 → 대부분 운영체제에서 작동하기 때문에 → 코드를 수정할 필요가 없음

### 가상 머신

- **운영체제와 ~ 응용 프로그램 사이에서 작동하는 프로그램**
- 가상 머신을 설치하면 → 응용 프로그램이 모두 동일한 환경에서 작동하는 것처럼 보임
- 자바로 만들어진 프로그램을 사용하기 위해서는 Java 가상 머신(Java Virtual Machine, JVM)을 설치해야 함
- 윈도우 운영체제 환경에서 유닉스를 사용하고 싶을 때 → 윈도우 운영체제에 리눅스 or 유닉스 **가상머신을 설치해서** 사용 (맥OS, 윈도우 동시 사용 가능)
- 가상머신을 사용하면 호환성이 높지만, 응용 프로그램이 가상머신에서만 작동하기 때문에 **느림**

## ☑️ 컴파일러와 인터프리터

알기 쉽게 만든 언어를 고급 언어라고 하고, 고급 언어로 짠 코드를 → 소스코드(source code)라고 함 → 컴터는 기계어만 인식하기 때문에, 소스코드를 기계어로 번역해야 함

### 대표적인 언어 번역 방식(3 - 컴파일러, 인터프리터, 어셈블러)

- **`컴파일러` compiler**
  - 소스 코드를 / 컴퓨터가 실행할 수 있는 기계어로 번역해 / **실행 파일**을 만든 후 → **한꺼번에** 실행 (C언어, 자바 등)
  - 컴파일러 사용 목적:
    - 소스 코드에서 오류를 발견해 실행할 때 문제가 없도록 하는 것
    - 최적화
  - 요리를 시작하기 전 레시피를 검토한 후 오류나 불필요한 내용 확인
- **`인터프리터` interpretor**
  - 소스 코드를 **한 번에 한 행씩** 번역해 실행 (JavaScript, Python 등)
  - 레시피에 적힌대로 위에서 아래로 한 줄씩 읽어가며 요리를 완성
- **`어셈블러` assembler**
