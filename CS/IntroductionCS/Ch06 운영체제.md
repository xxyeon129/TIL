# 01 운영체제 개요

운영체제(OS, Operating System): **사용자에게 편리한 인터페이스를 제공하고 / 자원을 효율적으로 관리하는 소프트웨어**

RAM 상주용 프로그램

컴퓨터나 노트북 전원을 켜면 가장 먼저 만나는 소프트웨어

- 운영체제를 내장한다 == 단일 기능이 아니라 여러 기능을 확장해 사용할 수 있다는 뜻
  - 스마트폰: 어플 설치 → 게임, 네비게이션 기능
  - TV: 시청, 동영상 감상, 인터넷 서핑, 쇼핑 등 다양한 기능 사용 가능

## 운영체제 핵심 기능

- **프로세스 관리**: 프로세스에 CPU를 배분하고 작업에 필요한 제반 환경 제공
- **메인 메모리 관리**: 프로세스에 작업 공간 배치, 실제 메인메모리보다 큰 가상 공간을 제공
- **저장 장치 관리**: 데이터를 저장하고 접근할 수 있는 인터페이스 제공

## 운영체제 종류

- 대형 컴퓨터: 유닉스 → 멀티 유저 멀티태스킹을 주 목적으로 함
- 개인용 컴퓨터: 윈도우, Mac OS, 리눅스(무료기 때문에 서버에 많이 사용) 등
- 스마트폰(모바일 운영체제): 애플의 iOS와 구글의 안드로이드
- 임베디드 운영체제
  - CPU 성능도 낮고 메모리 크기도 작아 → 특정 시스템에 내장할 수 있도록 만든 운영체제 (built-in; 내장된)
  - 일반 운영체제에 비해 몇 가지 기능이 빠짐
  - MP3 플레이어, PMP, 내비게이션, 스마트 시계, 스마트 TV 등에 사용
  - 주로 리눅스로 개발 → 리눅스 운영체제는 오픈소스이기 때문에 → 시계 등에 적합한 운영체제 개발 가능

## 운영체제 역할

- **성능 향상**: 새로운 기능 추가, 성능 변경 가능 → 성능 및 효율성 향상 가능
- **자원 관리**: 제한된 장치를 서로 독차지하려고 하는 응용 프로그램 사이에서 → 자원을 관리하는 중재자 역할을 함
- **자원 보호**: 악의적인, 미숙한 사용자에게서 자원을 보호
  - 모든 응용 프로그램은 운영체제 위에서 작동하기 때문에 → 운영체제가 불안정하면 → 다른 응용 프로그램도 함께 불안정
  - 운영체제는 바이러스나 악의적인 소프트웨어에서 하드웨어뿐 아니라 자기 자신도 보호
  - 운영체제는 사용자가 직접 자원에 접근하는 것을 막음으로써 자원을 보호
    - 직접 접근: 사용자가 커피를 직접 만드는 경우 (커피머신 보호 어려움)
    - 간접 접근: 커피를 바리스타에게 부탁하는 경우
- **사용자 인터페이스 제공**: 컴퓨터 하드웨어와 소프트웨어를 편리하게 사용할 수 있도록 환경 제공

## 운영체제 구조

크게 운영체제의 핵심 기능을 담당하는 **`커널`**과
사용자에게 작업 지시를 받고 결과를 알려주는 **`사용자 인터페이스`**로 구성

- **`커널`**: 프로세스 관리, 메모리 관리, 저장 장치 관리 같은 **운영체제의 핵심 기능**을 모아 놓은 것
  - 커널 내에는 드라이버와 시스템 호출 기능이 있음
  - **`시스템 호출`**: 운영 체제에서 어떤 작업을 부탁할 때는 시스템 호출을 사용
    - 사용자가 커널을 사용할 수 있도록 → 운영체제가 제공하는 → 프로그램 함수의 집합
    - 운영체제가 사용자나 응용 프로그램이 하드웨어에 직접 접근하지 못하게 막음으로써 컴퓨터 자원을 보호하는 함수의 집합
  - **`드라이버`**
    - 운영체제가 하드웨어 장치와 상호 작용하려고 만든 컴퓨터 프로그램
    - 장치 드라이버. 장치 제어기, 소프트웨어 드라이버라고도 함
    - 그래픽 카드나 프린터와 같이 복잡한 드라이버는 CD 형태로 제공
- **`사용자 인터페이스` (= 접속 환경)**: 운영체제가 사용자와 응용 프로그램에 인접하여 → 커널에 명령을 전달하고 + 실행 결과를 사용자와 응용 프로그램에 돌려주는 기능
  - GUI (Graphical User Interface), CLI (Command Line Interface)

## 운영체제의 역사

### 유닉스

- 멀티유저 멀티태스킹 → 여러명이 동시에 다중 작업을 할 수 있도록 해주는 소프트웨어(운영체제)
- 유닉스는 크게 **System V 계열**과 **BSD 계열**로 나눌 수 있다
- **유닉스 시스템 V** (Unix System sysV, 시스템5): 소스 코드를 공개 → 많은 사람이 개선 발전시켜 현재까지 내려온 유닉스
- **BSD** (Berkeley Software Distribution): 계속 발전해 누구나 무료로 사용할 수 있는 FreeBSD로 발전

### 리눅스

개인용 컴퓨터에서 동작하는 **유닉스 호환 커널**을 만들어 공개

- FreeBSD를 기반으로 만들었기 때문에 → 누구나 무료 사용, 소스 코드 공개
- 구글이 리눅스 커널을 가져다가 → 스마트폰에서 사용할 수 있는 안드로이드 운영체제를 개발
- 리누스 토르발스가 PC용으로 만든 유닉스

### Mac OS

- 애플은 FreeBSD를 변형해 → 매킨토시 컴퓨터에서 동작하는 운영체제 개발 (오픈소스가 아님. 폐쇄형 OS → 보안이 우수)
- 현재 OS X로 발전해 → 애플용 컴퓨터, 노트북에서 사용
- iOS: OS X를 스마트폰용으로 바꾼 것

### GNU (GNU is Not Unix)

- 유즈넷을 통해 일반인에게 알려짐
- 소프트웨어를 돈 주고 사는 대신, 누구나 자유롭게 실행, 복사, 수정, 배포할 수 있게 하자고 주장
- GPL (General Public License) → GNU 정신에 입각해 만든 소프트웨어에 주어진 라이선스(저작권. 누구든지 쓸 수 있게 사용할 수 있는 권리 보장)
- 자선 단체 자유 소프트웨어 재단 (Free Software Foundation, FSF) 설립
  - 자원 봉사자가 개발 참여해 많은 소프트웨어 개발, 배포
  - 리눅스나 안드로이드는 GNU 결과물로 만든 운영체제이므로 → 무료 사용

### Windows

MS-DOS(Disk-Operating-System)에 그래픽 사용자 인터페이스(GUI)를 붙인 것

윈도우는 3.1로 시작해 ~ 현재 10버전까지 출시

- 마이크로소프트 개발 → 무겁고 불안한 운영체제
- 윈도우 운영체제 중단 시 → 파란 화면이 나타나고, 작업하던 모든 데이터가 사라짐
- 무료 사용이 가능한 리눅스 → 안정적이고 강력한 운영체제 BUT 일반인이 사용하기 어려워서(낯설어) 윈도우를 유로로 사용

GPL은 소프트웨어를 돈 주고 사는 대신 누구나 자유롭게 실행, 복사, 수정, 배포할 수 있게 한다

# 02 프로세스 관리

## 프로그램 vs. 프로세스

- **`프로세스 process`: CPU, Memory 할당 받아서 → 실행 중인 프로그램**
  - 하나의 작업 단위
  - 사용자가 마우스를 더블클릭해 프로그램을 실행하면 → 프로그램은 프로세스가 됨
  - **프로그램으로 작성된 작업 절차를 실제로** 실행에 옮긴다는 의미(’실행한다’고 표현)
  - 해당 코드가 메모리(RAM)에 올라와서 작업이 진행된다는 의미
- **`프로그램`**: 어떤 데이터를 사용해 어떤 작업을 할지 → 그 절차를 적어 놓은 것
  - 하드디스크 같은 저장 장치에 보관하고 있다가 마우스로 더블클릭하면 실행
- 프로세스 제어 블록 Process Control Brock, PCB: 운영체제에서 **주문서에 해당하는 것**
  - 프로세스 = 프로그램 + 프로세스 제어 블록
  - 프로그램 = 프로세스 - 프로세스 제어 블록
  - 사용자가 (저장 장치에 있는) 프로그램을 실행시키면 → 프로세스는 메모리로 올라오고, → 해당 프로세스의 PCB가 생성된다.
- Ex. 팟플레이어
  - 하드 디스크에 저장된 프로그램 중 하나 → 저장 장치에 보관된 **정적인 상태**
  - 팟플레이어를 실행시키면 → 프로세스가 됨 → 메모리에 올라와서 작업을 수행하는 **동적인 상태**

## 프로그램의 상태

- 일괄 처리 작업 (batch job)
  - 한 번에 작업을 한 개만 처리하는 시스템
  - 컴퓨터 초창기 운영체제나 MS-DOS가 사용하던 방식
  - ex. 시험지 한번에 모아서 처리하는 것
- 시분할 작업 (timesharing job)
  - 프로세스 여러 개가 / 아주 짧은 시간 동안 / CPU를 사용하는 방식)
  - **프로세스 여러 개가 / 동시에 실행되는 것처럼 보이는 작업**
  - ex. 요리사의 여러 단품 요리 조리

## 프로세스의 상태

- **`생성 상태 create status`**
  - (더블클릭해서) 프로세스가 메모리에 올라와 실행 준비를 완료한 상태 → PCB(프로세스 제어 블록) 생성
- **`준비 상태 ready status`**
  - 생성된 프로세스가 CPU를 얻을 때까지 기다리는 상태
- **`디스패치 dispatch`**
  - 준비상태에서 → 실행 상태로 상태 전이
  - 다음 실행할 프로세스를 결정해 CPU 사용권을 주는 조작 (우선순위 결정)
- **`타임아웃 인터럽트`**
  - 프로세스가 CPU를 자발적으로 반납하지 않고 / 독점 방지를 위해 → 하드웨어적으로 인터럽트 클록을 발생시켜 → 특정 시간 동안만 실행하도록 → CPU제어권을 빼앗음
- **`실행 상태 running status`**
  - 준비 상태에 있는 프로세스 중 하나가 CPU를 얻어 실제 작업을 수행하는 상태
  - 자신의 작업이 끝날 때까지 준비 상태와 실행 상태를 반복
  - 프로세스의 주요 상태 중 / 프로세스 제어 블록을 만든 상태
  - 프로세스의 주요 상태 중 / CPU를 얻는 상태
- **`완료 상태 terminate status`**
  - 실행 상태의 프로세스가 주어진 시간 동안 작업을 마치면 → 완료 상태로 진입, PCB 반납
  - 프로세스 제어 블록이 폐기되는 상태

# 03 메인메모리 관리

## ✅ 메모리 관리

- 폰노이만 구조 컴퓨터에서 → 메모리는 유일한 작업 공간
- **모든 프로그램은 메모리에 올라와야 실행이 가능**
- 과거 일괄 처리 시스템 → 한 번에 하나의 작업만 처리 → 메모리 관리가 쉬움
- BUT 오늘날 **시분할 시스템** → (운영체제 포함) 여러 프로세스가 한꺼번에 메모리에 올라오기 때문에 → **메모리 관리가 복잡**

## ✅ 메모리 구조

- 운영체제도 프로세스 → 메모리에 올라와야 실행이 가능
- 메모리 관리 시스템 → **운영체제 영역과 다른 작업 영역의 침법을 막기**
  - 자리 부족 시 빈 공간을 확보

## ✅ 메모리 관리자가 하는 일 (가져오기, 배치, 재배치)

### 1. 가져오기 작업

**프로세스와 데이터를 → 메모리로 가져오는 것**

### 2. 배치 작업 (memory placement strategies, memory allocation)

**가져온 프로세스와 데이터를 → 메모리의 어떤 부분에 올려놓을지 결정하는 것**

- 배치 작업 전에, 같은 크기로 자르느냐 or 프로세스 크기에 맞게 자르느냐에 따라 → 복잡성이 달라짐
- **`최초 적합` (first-fit)**
  - 주기억 장치의 사용 가능한 공간을 검색해서 → **첫 번째로 찾아낸 곳을 할당하는 방식**
  - 검색은 공간의 첫 부분부터 수행하거나 or 지난 번 검색이 끝난 곳에서 시작한다 (next-fit)
  - 충분한 크기의 공간을 찾으면 → 검색을 끝낸다.
- **`최적 적합`** **(best-fit)**
  - 사용 가능한 공간들 중 → 크기 차이가 가장 작은 것을 선택하는 방식
  - if (가용 공간들에 대한 목록이 / 공간들의 크기 순서대로 정렬되어 있지 않다면) → (최적인 곳을 찾기 위해) 전체를 검색해야 한다.
- **`최악 적합`** **(worst-fit)**
  - 사용 가능한 공간들 중 → 크기가 가장 큰 것을 선택하는 방식
  - 할당해주고 남는 공간을 크게 해서 → 다른 프로세스들이 그 공간을 사용할 수 있도록 하는 전략
  - if (가용 공간들에 대한 목록이 / 공간들의 크기 순서대로 정렬되어 있지 않다면) → (최적인 곳을 찾기 위해) 전체를 검색해야 한다.

### 3. 재배치 작업

꽉 차있는 메모리에 새로운 프로세스를 가져오기 위해 → 오래된 프로세스를 내보내는 작업

메모리가 꽉 찬 경우 → 메모리에 있는 프로세스를 하드디스크로 옮겨놓는 작업

## ✅ 가상 메모리

- **메모리 크기를 고려한 개발**
  - 사용자 메모리는 1GB부터 16GB까지 다양
  - 동작 프로그램에 따라 → 작은 메모리에서는 동작하지 않을 수 있음 → 메모리 크기를 고려해 프로그래밍하기는 매우 어려움

### 가상 메모리

사용자가 가지고 있는 **실제 메모리 크기와 + 프로세스가 올라갈 메모리 위치를 / 신경쓰지 않고 프로그래밍을 하도록 지원하는 / 메모리 시스템**

- 실제 메모리 크기와 상관 없이 / 프로세스에 커다란 메모리 공간을 제공하는 기술
  - 가상 주소 공간은 → 메모리 관리 장치에 의해 / 물리적 주소로 변환된다
  - 프로그래머는 가상주소 공간에서 프로그램을 작성하게 되어 → 프로그램이나 데이터가 주메모리상에서 어떻게 존재하는지 의식할 필요가 X

### **가상 메모리 구성**

- 가상 메모리 = <프로세스가 바라보는 메모리 영역> + <메모리 관리자가 바라보는 메모리 영역>으로 나뉨
- 이론적으로 가상 메모리 크기는 무한대

- **`스왑 영역`**
  - **메모리가 모자라서 쫓겨난 프로세스를 → 저장 장치의 특별한 공간에 모아두는 영역**
  - 하드디스크 같은 저장 장치는 → 장소만 빌려주고 / 메모리 관리자가 담당
  - [최대 절전 모드] 사용 시 → CPU와 메모리의 전력 공급을 끊기 때문에 → **현재 메모리에 있는 데이터**(메모리의 내용)**를 옮겨 가는 곳이 스왑 영역**

### 가상 메모리 크기

가상 메모리 크기 = 실제 메모리 크기 + 스왑 영역 크기

가상 메모리 시스템은 → **실제 메모리와 + 스왑 영역을 활용해 → 메모리 크기에 상관 없이 / 모든 프로그램을 실행할 수 있는 시스템**

- 스왑 영역 크기 → **사용자가 조절 가능, but 너무 작게 하면 프로그램 실행이 불가능할 수 있음**

# 04 저장 장치 관리

## ✅ 파일

### 파일 확장자

파일 == 논리적인 데이터 집합

- (하드 디스크나 CD와 같은) 제 2 저장 장치에 저장
- 파일 구분 → 확장자 사용,
  확장자에 따라 → 파일 성격 구분 - 컴퓨터 내에는 여러 종류의 파일이 있는데, 이를 구분하려고 파일 확장자를 사용한다.
- **표기: 파일이름.확장자**
- 초창기 운영체제 → 파일 이름은 여덟 글자, 확장자는 세 글자로 제한
- **파일 이름**
  - 마지막 마침표 다음 글자를 확장자로 인식
  - 현재 경로 이름을 포함해 **최대 255자**
  - 원 표시, /, :, \*, ?, “, <, >, | 등은 사용 불가
- mp3, bmp, jpg, zip 등과 같이 전 세계적으로 표준을 정해 사용
- 응용 프로그램 제작자가 필요에 따라 새로 만들어서 사용 가능
- **파일 포맷**

  - 이미지 파일 포맷: BMP, JPG…
  - 음악 파일 포맷: MP3, WAV …

- **`파일 헤더`**: 파일 이름, 버전, 크기, 만든 날짜 등 정보가 저장 (파일에는 파일 헤더가 존재)

### 실행 파일과 데이터 파일

- **`실행 파일`**: **운영체제가 → 메모리로 가져와 → CPU를 사용해 → 작업하는 파일 (사용자 요청으로 프로세스가 되는 파일)**
- **`데이터 파일`**: 프로세스나 응용 프로그램이 사용하는 데이터를 모아놓은 파일

### 연결 프로그램

데이터 파일을 더블 클릭하면 실행되는 응용 프로그램

- 연결 프로그램 변경: 오른쪽 버튼 → 속성 → 변경 → 프로그램 선택

## ✅ 디렉터리

**관련 있는 파일을 하나로 모아 놓은 곳**

여러 계층으로 구성 가능 (디렉터리 밑에 또 다른 디렉터리를 만들 수 있음)

최상위 디렉터리 → 루트 디렉터리(root directory)라고 함

### 디렉터리 계층 구조

- 역슬래시(`\`) → 루트 디렉터리를 의미
- 한글 자판에서 역슬래시는 원화 표시로 대체
- **디렉터리 헤더에는** → 디렉터리 이름, 만든 시간, 접근 권한 등 정보가 기록되어 있음

## ✅ 파일 시스템

### **파일 테이블**

- 파일이 저장된 **파일 이름, 위치 정보** 등이 저장
- 운영체제는 파일이 저장되어 있는 위치 정보를 파일 테이블에 저장한다
- 모든 운영체제는 **고유의 파일 테이블을 가짐**
  - 윈도우: NTFS
    유닉스: i-node 같은 파일 시스템 운영

### 포맷팅

디스크에 파일 시스템을 탑재하고 + 디스크 표면을 초기화하여 → 사용할 수 있는 형태로 만드는 작업

- **`빠른 포맷`**: 기존 파일 시스템이 삭제되고, 새로운 파일 시스템 생성
  - **데이터 영역의 데이터는 그대로 보존된다.**
  - 데이터 영역의 데이터를 직접 삭제할 필요 X
  - 파일 시스템만 삭제하면 되기 때문에 → 디스크 포맷이 빠르게 수행된다.
- **`일반 포맷`**: 기존 파일 시스템이 삭제되고, 새로운 파일 시스템 생성
  - **데이터 영역의 데이터도 제로로 채워짐**
  - **데이터 영역의 데이터를 “00”으로 채우고**, 파일 시스템도 함께 삭제
  - → 디스크 포맷하는데 오랜 시간이 걸린다.

### 섹터

- **하드 디스크의 물리적인 구조상 가장 작은 저장 단위**
- 섹터마다 주소를 부여하면 → 너무 많은 양의 주소가 필요하기 때문에 → **파일 관리자**는 **여러 섹터를 묶어 하나의 블록으로** 만들고, → **블록 하나에 주소 하나를 배정함**

### 블록

- **저장 장치에서 사용하는 가장 작은 단위**
- **한 블록에 주소 하나를 할당**
- 데이터는 운영 체제와 저장 장치 간에 블록 단위로 전송
- 블록 크기
  - 블록 크기는 시스템마다 다름
  - 포맷할 때 시스템이 정한 기본 블록 크기를 사용 or 직접 지정
  - **블록 크기를 작게 설정하면 → 저장 장치를 효율적으로 쓸 수 있지만,**
    **파일이 여러 블록으로 나뉘어 → 파일 입출력 속도가 느려짐**

하드 디스크 같은 저장 장치의 저장 단위는 섹터이지만, 운영체제와 저장 장치 간 데이터 전송 단위는 블록이다.

### 조각화 (단편화)

- 하드디스크를 처음 사용할 때 → 데이터가 앞부터 차곡차곡 쌓이지만,
  **사용하다 보면 → 파일이 삭제되면서 중간중간 빈 공간이 생김**
- 하드디스크에 **조각이 많이 생기면 → 큰 파일을 여러 조각으로 나누어 저장 → 성능 저하**

### 조각 모음

- 주기적으로 조각 모음 실행
- 시간이 오래 걸리는 작업이므로 → 작업이 없는 특정 시간에 조각 모음을 실행
- USB 메모리, SSD 등 반도체를 사용하는 저장 장치는 → **조각 모음을 하지 않음**
- **조각 모음을 통해 → 특정 위치의 메모리만 계속 사용하면 → 수명 단축**

### FAT 파일 시스템 구조

- **왼쪽 테이블 → 파일 정보와 함께 + 파일의 시작 블록 정보를 가짐**
- **`NULL`**: 아무것도 없음을 의미
  - 0이나 공백과는 다른 의미
  - C언어에서 메모리의 데이터 → 포인터가 지정하는 곳의 데이터를 가져옴
  - 포인터가 더 이상 아무것도 가리키고 있지 않음 or 포인터가 가져올 값이 없음을 표시

### FAT32와 NTFS(New Technologt File System)

윈도우는 파일 시스템으로 → NTFS를 사용 (FAT32는 사용하지 않음)

**`FAT31`**

- 32GB까지 지원, **파일 하나의 크기가 4GB로 한정** (2^32 = 4GB)
- USB 메모리가 대부분 사용
  - 4GB보다 큰 파일을 저장하려고 하면 → 빈 공간이 있어도 ‘빈 공간 없음’ 메시지 표시
  - → FAT32가 4GB 이상의 파일을 지원하지 않아 발생하는 문제
  - NTFS 파일 시스템으로 바꾸면 해결
  - exFAT(Extended FAT) = FAT64

## 빈 공간 관리

### 디지털 포렌식 기술

- **디지털 기기로 발생한 특정(범죄) 행위 사실관계를 → 법정에서 규명하고 증명하기 위한 → 절차와 방법**
- **디지털 기기에 들어있는 데이터를 수집, 추출한 후 → 이를 바탕으로 범죄 단서, 증거 찾아내는 과학 수사 기법**
  - 사전적 의미 → 법의학, 최근에는 ‘범죄에 관한 과학 수사’라는 포괄적 의미로 많이 사용
- _하드 디스크_

### 빈 공간 리스트

- 저장 장치의 빈 공간은 빈 공간 리스트가 관리한다.
- 디스크에 파일 저장 시 → 모든 테이블을 뒤져 빈 공간을 찾는 건 비효율적임
- 빈 공간 효율적 관리 위해 → **파일 시스템**은 빈 블록 정보만 모아 놓은 **`빈 공간 리스트`**를 유지
- **파일 삭제 → 실제 파일이 지워지는게X** → 파일 테이블의 헤더를 삭제하고 + 사용한 블록을 빈 공간 리스트에 등록함

- 빠른 포맷 → 데이터를 그대로 남겨 둔 채 → 파일 테이블만 초기화하는 방식
  - **블록 내용을 지우지 않고 + 빈 공간 리스트 삽입** → 해당 블록에 새로운 데이터를 덮어쓰지 않는 한 원래 데이터를 복구할 수 있는 여지가 있음
- 빈 공간 리스트에 새로운 블록을 할당할 때 → 리스트에 먼저 들어온 블록부터 할당
  → 휴지통에서 삭제한 파일이나 빠른 포맷을 한 이후 **데이터를 되살릴 수 있음**

파일 삭제 또는 포맷 후 저장 장치의 상태

- **데이터 관리**
  - 파일 지우면 → 파일 내용이 사라지는게 X → **파일 테이블에서 파일 정보만 삭제**
  - 새로운 파일을 저장하면 → 방금 지운 파일 공간에 덮어쓰는게 X → **앞의 빈 공간부터 덮어씀**
  - 스마트폰 클라우드 저장 장치 → 전화번호부, 사진, 파일 클라우드로 전송
    - → 데이터를 지워도 클라우드로 전송한 데이터를 지우기 전까지는 시간 차이가 있을 수 있음
